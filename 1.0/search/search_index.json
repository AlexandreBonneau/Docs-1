{"config":{"indexing":"full","jieba_dict":null,"jieba_dict_user":null,"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"faq/","text":"<p></p> <p>Below, we have a list of frequently asked questions about ELRS</p>","title":"FAQ"},{"location":"faq/#why-expresslrs","text":"<p>ExpressLRS is competing with some of the best commercial solutions out there, but all are expensive \ud83d\ude41. Well, ELRS is not \ud83d\ude04, it can be set up for around 60$ (Using second-hand r9 hardware). It also is better than many (higher sensitivity, lower latency\ud83d\udc4c).</p>","title":"Why ExpressLRS?"},{"location":"faq/#is-it-better-than-the-commercial-solutions","text":"<p>It is faster than most links out there with a latency of 6.5ms (at 200hz). At 250hz 100mW 2.4GHz it is capable of ranges 30km+.</p>","title":"Is it better than the commercial solutions?"},{"location":"faq/#which-opentx-version-works-with-expresslrs","text":"<p>OpenTX 2.3.12 or newer should work just fine. No need to use OpenTX Nightly, unless you have requirements not present in the Stable versions.</p> <p>EdgeTX 2.4.0 or newer should work too.</p>","title":"Which OpenTX version works with ExpressLRS"},{"location":"faq/#why-do-i-need-to-update-opentx","text":"<p>ExpressLRS needs your radio to support crsfshot (a.k.a. Mixersync) to work properly. This will give you the lowest possible latency and optimal consistency of the RC link. When your radio does not have crsfshot working, this often shows in your ExpressLRS Lua script. The Lua script top bar will show inconsistent numbers like 0:63 or is stuck at 0:250 at every packet rate rate you select.</p> <p>The Lua script top bar should always show a stable 0:[user selected packet rate]</p> <p>For example: 0:50, 0:150, 0:250, 0:500, ...</p> <p>When that is the case your radio has crsfshot working and you're good to go. Click here to read more on OpenTX.</p>","title":"Why do I need to update OpenTX?"},{"location":"faq/#how-can-i-flashupdate-x-receivermodule","text":"<p>See Getting Started page</p>","title":"How can I flash/update x receiver/module?"},{"location":"faq/#will-x-receiver-work-with-y-tx-module-from-z-manufacturer","text":"<p>Any Receiver and TX Module from the same Band (2.4GHz or 900Mhz) will work together. Supported R9 receivers will work with the 900Mhz modules from Happy Model, Namimno RC and the R9M, same with the other 900Mhz receivers, DIY or off-the-shelf. Likewise, any 2.4Ghz receivers should work with any 2.4Ghz TX Modules, from any manufacturer and even the DIY ones. This is as long as they have the same binding phrase and configuration options (Regulatory Domain, Performance Options and Extra Data).</p>","title":"Will x Receiver work with y TX Module from z Manufacturer?"},{"location":"faq/#whats-the-difference-between-the-different-happymodel-24ghz-receivers-pp-ep1-ep2","text":"<p>The difference between the PP and the EP1/EP2 is only the processor. The PP is the original design and uses an STM32 while the EP1/EP2 use an ESP82xx. Both offer firmware update through Betaflight passthrough, but the EPx also support firmware upload over wifi. The EP1 is the same as the EP2 except it has a U.FL/IPEX1 connector for an external antenna. The wifi capability of the ESP is not used apart from the update procedure, and the wifi is only enabled shortly after power-up if no TX connection is received (<code>AUTO_WIFI_ON_INTERVAL</code> if bound, 60s otherwise). Receiver performance should be identical between the two. If you're confused by the PP being more expensive, it's because there is a shortage of the STM part.</p>","title":"What's the difference between the different Happymodel 2.4GHz receivers (PP, EP1, EP2)?"},{"location":"faq/#what-is-required-to-achieve-a-500hz-update-rate-on-24ghz-on-opentx","text":"<p>Make sure to enable the \"Use_500hz\" option when you flash the TX and RX. You must also be on a version of OpenTX that supports Mixer Sync (TBS Nightly, ELRS Nightly, OpenTX 2.3.12 or newer, or EdgeTX). USE_500Hz option is now enabled be default starting with 1.0.0-RC9 (6358aa).</p> <p>To confirm your update rate is working as intended, you can use the ExpressLRS Lua script to check the current update rate and confirm you are getting 500hz.</p>","title":"What is required to achieve a 500hz update rate on 2.4ghz on OpenTX?"},{"location":"faq/#how-many-channels-does-elrs-support","text":"<p>12 channels(suspicious asterisk). There is not enough bandwidth to support all full-resolution channels (e.g. for pan/tilt servos). It is possible that future versions could include some tricks to expand this by sending extra channel data in a slow upload, but it is not a priority for development. Therefore, ELRS provides:</p> <ul> <li>4x full-resolution (10-bit) channels for sticks (CH1-4)</li> <li>Either:<ul> <li>Standard Mode 4x 2-position channels sent every frame (increased to 8x in 1.0), OR</li> <li>HYBRID_SWITCHES_8 Mode 8x 3-position channels, where CH5 (AUX1/ARM) is sent every frame, and the other 7 are sent round-robin (7 frames to send all channels) also changed in 1.0, see Switch Modes</li> </ul> </li> </ul>","title":"How many channels does ELRS support?"},{"location":"faq/#is-my-binding-phrase-a-secret","text":"<p>No, just like what channel your VTX is on is not a secret. The binding phrase is not security, it is anti-collision. If everyone kept their VTX channel a secret, the chances of you blasting someone out of the sky accidentally is pretty high. To provide the best chance of not interfering with other pilots and them not interfering with you, be sure you're not using the same dumb bind phrase as someone else. Express your style with a hilarious or saucy bind phrase.</p>","title":"Is my binding phrase a secret?"},{"location":"faq/#what-does-rqly-tqly-rssi-x2-snr-x2-mean","text":"Datapoint Description Range Info     RQly Uplink - link quality (valid packets) 0 - 100 The number of successful packets out of the last 100 from TX \u2192 RX   1RSS Uplink - received signal strength antenna 1 (RSSI) -128 - 0 RSSI dBm as reported by the RX. Values vary depending on mode, antenna quality, output power and distance   2RSS Uplink - received signal strength antenna 2 (RSSI)  Second antenna RSSI, used in diversity mode   ANT RX active Antenna  Not populated currently   RSNR Uplink - signal-to-noise ratio  SNR reported by the RX. Value varies mostly by radio chip and gets lower with distance (once the agc hits its limit)   RFMD Uplink - update rate     TPWR Uplink - transmitting power  50mW reported as 0, as CRSF/OpenTX do not have this option   TQly Downlink - link quality (valid packets) 0 - 100 An LQ indicator of telemetry packets received RX \u2192 TX   TRSS Downlink - received signal strength (RSSI)  RSSI dBm of telemetry packets received by TX   TSNR Downlink - signal-to-noise ratio  SNR reported by the radio in the TX module when receiving telemetry packets","title":"What does RQLY, TQLY, RSSI x2, SNR x2 mean?"},{"location":"faq/#is-it-normal-to-get-rf-signal-critical-when-plugging-in","text":"<p>Yes. When the connection is first established, the link quality starts at 0 and climbs as packets are received. Expect low RF Signal warnings until enough packets are reported received to pass your warning threshold set in OpenTX -&gt; Telemetry -&gt; RSSI -&gt; Low alarm / Critical alarm.</p>","title":"Is it normal to get \"RF Signal Critical\" when plugging in?"},{"location":"license/","text":"<p>MIT License</p> <p>Copyright \u00a9 2016-2021 Martin Donath</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>","title":"License"},{"location":"hardware/diy-rx/","text":"<p> Possibly one of the biggest benefits from using <code>ExpressLRS</code> is custom hardware!</p> <ul> <li>\ud83d\udcf6 Custom ESP 2.4 GHz RX</li> <li>\ud83d\udce1 Custom ESP 900 MHz RX</li> <li>\u26a1 Flashing ESP Based RX</li> </ul>","title":"DIY Receiver"},{"location":"hardware/diy-rx/#custom-esp-24-ghz-rx","text":"<p></p> <ul> <li>20x20 footprint and uses 0805 size SMD components. SMD components have been positioned on the PCB in a soldering iron friendly way. \ud83d\udeb8 </li> </ul> <p></p> <ul> <li>The <code>ELRS Nano</code> RX is 18mm x 11mm and uses the same pinout as the <code>Crossfire Nano</code> RX. This allows for direct mounting to compatible flight controllers. \u26a0\ufe0f This PCB uses 0402 SMD components and will require a hot air rework station and probably a microscope. \ud83d\udd2c </li> </ul>","title":"Custom ESP 2.4 GHz RX"},{"location":"hardware/diy-rx/#custom-esp-900-mhz-rx","text":"<p>  </p> <ul> <li>Uses the <code>ESP-01F</code> for WiFi and a <code>RFM95</code> for our business \ud83d\udd74\ufe0f</li> <li>Requires ordering PCBs from Gerber files, a regulator chip, a few passives, a <code>ESP-01F</code> and a <code>RFM95</code> (915/868MHz)</li> <li>Multiple RX PCB designs are available \u2705 </li> <li><code>20x20 RX</code> - discrete SMD antenna for Wifi and RF directly soldered to PCB<ul> <li>Target DIY_900_RX_ESP8285_SX127x_via_UART</li> </ul> </li> <li><code>20x20 RX 0805</code> - easier to build due to bigger SMD parts. PCB antenna for Wifi and <code>u.fl</code> connector for RF</li> <li><code>Mini RX</code> - the smallest form factor, lightest weight and lowest cost per PCB</li> <li>If you need help soldering, please check out this video</li> </ul>","title":"Custom ESP 900 MHz RX"},{"location":"hardware/diy-rx/#flashing-custom-rx","text":"","title":"Flashing Custom RX"},{"location":"hardware/diy-rx/#before-you-start","text":"<ul> <li>The steps for building are in each individual <code>README.md</code> for the RX of your choice</li> <li>If you are using an <code>ESP-12F</code> instead of <code>ESP-01F</code> it is recommended to follow this tutorial but using the appropriate RX target \ud83e\uddd1\u200d\ud83c\udfeb </li> </ul>","title":"Before you start"},{"location":"hardware/diy-rx/#get-it-flashed","text":"<ul> <li>Connect the serial adapter to <code>GND</code>, <code>TX</code>, <code>RX</code>, and the appropriate <code>3V3</code> or <code>5V</code>.</li> <li>Additionally, connect <code>IO0</code> to <code>GND</code> to activate the bootloader and enable flashing</li> <li>Quite some serial adapters have <code>TX</code> and <code>RX</code> swapped, mislabeled, or both \ud83d\ude38. Please double-check!</li> <li>Finally, select the appropriate RX target, make sure your user defines are correct, and press <code>Upload</code> in platformio</li> </ul>","title":"Get it flashed"},{"location":"hardware/diy-tx/","text":"<p></p>","title":"DIY Transmitter"},{"location":"hardware/diy-tx/#custom-esp-24-ghz-tx-for-jr-module-bay","text":"<p>All of the info on this topic can be found \ud83d\udc49Here</p> <p></p>","title":"Custom ESP 2.4 GHz TX (for JR module bay)"},{"location":"hardware/diy-tx/#custom-super-slim-esp-24-ghz-tx-for-lite-module-bay","text":"<p>The super slim is an evolution of the slim. It uses the same base hardware as the JR size one. It's the same size as an R9M Lite, and fits in all handsets with a lite module bay such as the X-Lite, X9 Lite, and Tango 2 (with the proper adapter). The rest of the info can be found \ud83d\udc49Here</p> <p></p>","title":"Custom Super Slim ESP 2.4 GHz TX (for lite module bay)"},{"location":"hardware/esp-backpack/","text":"<p></p> <p>Addon for R9M modules and HappyModel ELRS915TX to allow:</p> <ul> <li>Wireless firmware update via ExpressLRS Configurtor</li> <li>Flashing ESP Backpack (self)</li> <li>Flashing R9M TX locally via browser</li> <li>Logging to Browser and via Websocket</li> <li>Possibly more.. wireless trainer mode? Please contribute \ud83e\udd47 </li> </ul> <p>This is a convenience feature for development purposes and \"power users\" - soldering can be tricky - please be careful. \ud83d\udc6e  This feature is built into most off-the-shelf ELRS TXes now too.</p>","title":"ESP Backpack"},{"location":"hardware/esp-backpack/#parts","text":"<ul> <li>USB to Serial Dongle (aka FTDI Stick)</li> <li>R9M (previously flashed with ExpressLRS) \ud83d\udce1 </li> <li>any ESP 8266/8285 based chip should work, recommended are</li> <li>ESP01F for quick install (internal resistors ease initial flashing, but wire antenna)</li> <li>ESP12F for pcb wifi antenna, FCC/CE certififed (but more complex circuit required for initial flashing)</li> <li>very thin wire (AWG30 \"kynar\"); or enameled wire if you are good with routing (0.5mm holes in PCB)</li> <li>depending on your soldering skill using flux and leaded solder is recommended</li> </ul>","title":"Parts"},{"location":"hardware/esp-backpack/#board-esp01f-esp8285","text":"<ul> <li>Connect the serial adapter to <code>3.3V</code>, <code>GND</code>, <code>TX</code> and <code>RX</code></li> <li>\ud83d\udd25 <code>3.3V</code> NOT <code>5V</code></li> <li>Additionally, connect <code>IO0</code> to <code>GND</code> to activate the bootloader and enable flashing</li> <li>Quite some serial adapters have <code>TX</code> and <code>RX</code> swapped, mislabeled, or both \ud83d\ude38. Please double check!</li> </ul>","title":"Board ESP01F (ESP8285)"},{"location":"hardware/esp-backpack/#board-esp12f-esp8266","text":"<p>This module needs a more complex circuit to get flashed:</p> <p></p>","title":"Board ESP12F (ESP8266)"},{"location":"hardware/esp-backpack/#esp-module-firmware","text":"<p>Before connecting the ESP module to the TX module, you need to flash the ESP module with the latest TX Backpack firmware. To transfer the ESP module to the firmware mode, it is necessary to connect the <code>IO0</code> and <code>GND</code> pins before connecting the programmer to the computer.</p>","title":"ESP module firmware"},{"location":"hardware/esp-backpack/#connecting-to-r9m-2018-old-version-module","text":"<p>Let's get together:</p> <ul> <li>Solder wires connecting <code>RX1</code>, <code>TX1</code>, <code>NRESET</code>, and <code>BOOT0</code> pins \ud83d\udd0c </li> <li>\u2757 Removing transistor <code>J6</code> is not required in contrary to as shown on the picture</li> <li>Please note the alternative location to reach <code>TX1</code> to keep you from having to solder on the chip's leg \ud83d\udc81</li> </ul> <p> </p>","title":"Connecting to R9M 2018 (Old version) Module"},{"location":"hardware/esp-backpack/#connecting-to-r9m-2019-module","text":"<p>The ESP module is wired:</p> <ul> <li>GPIO5 -&gt; ESP IO5</li> <li>GPIO4 -&gt; ESP IO4</li> <li>GPIO0 -&gt; ESP IO0 (It is necessary to cut the wiring leading to the button.)</li> <li>GPIO16 -&gt; ESP IO16 (If desired, an LED and a current-limiting resistor of 0.5-1.5kOm must be added to the circuit.)</li> <li>TX -&gt; ESP RX</li> <li>RX -&gt; ESP TX</li> <li>3.3v -&gt; ESP 3.3v</li> <li> <p>GND -&gt; ESP GND</p> </li> <li> <p>The button is required to enable the access point mode on the ESP.</p> </li> <li>The LED is required to indicate the operation of the ESP access point mode. If it is not needed, it can be omitted.</li> </ul> <p> </p>","title":"Connecting to R9M 2019 Module"},{"location":"hardware/esp-backpack/#connecting-to-happymodel-elrs915tx","text":"<p>The ESP module is wired:</p> <ul> <li>NRSET -&gt; ESP DIO5</li> <li>BOOT0 -&gt; ESP DIO4</li> <li>TX -&gt; ESP RX</li> <li>RX -&gt; ESP TX</li> <li>3.3v -&gt; ESP 3.3v</li> <li>GND -&gt; ESP GND</li> </ul> <p>Updating the ELRS915TX over wifi is supported from 1.0.0 RC8 onwards.</p> <p> </p>","title":"Connecting to Happymodel ELRS915TX"},{"location":"hardware/esp-backpack/#connect-via-wifi","text":"<p>Initially, the module will open an accesspoint for you to connect and change the settings to your desire. This accesspoint is available at the <code>ESP Wifi Manager</code> wifi network. Then navigate to http://elrs_tx.local/, and after building your firmware, upload the file to the website and flash.</p> <p></p>","title":"Connect via WiFi"},{"location":"hardware/esp-backpack/#why-does-the-es24tx-have-a-wifi-ap-is-there-any-way-to-turn-it-off","text":"<p>No, there is no way to disable it, HappyModel should not have put any firmware on it. You're welcome to wipe it with esptool.</p>","title":"Why does the ES24TX have a wifi AP, is there any way to turn it off?"},{"location":"hardware/fan-mod/","text":"<p></p> <p>Initially this mod is brought to life by Niklas Voigt and Seba112PL as beta tester and is still a work in progress.. if you have suggestions don't hesitate to contact.</p>  <p>DISCLAIMER</p> <p>Users have experienced temperature issues on R9M that degrades the link quality. We recommend you use the lowest power setting required for your flight and turn on dynamic power at all times (ELRS v2.0+)</p>   <p>Hot Tip</p> <p>It might seem counterintuitive, but using less power might help for longer flight times and more range by reducing the heat. ELRS does not require a lot of energy and looking at the long-range leader board</p>","title":"R9M Fan Mod"},{"location":"hardware/fan-mod/#1w-mod","text":"<p>WARNING</p> <p>With this mod your R9M is still limited to 1W</p>  <p></p> <p>You need a 20x20mm or 25x25mm fan in 5V version.  Both sizes are supported. To secure the fan into the cover you can use 2x M2 screws, a thread is already in the print. U can solder the pins of the fan directly to the 5v port of the R9M or use the Controllable Fan Mod which can control the fan out of software (fan blows only at &gt;250mw). </p> <p>R9M Fan Mod Cover is build out of four Parts and a Sticker:</p> <p></p>","title":"1W Mod"},{"location":"hardware/fan-mod/#download","text":"<ul> <li>R9M-Fan-Case-Cover.stl</li> <li>R9M-Fan-Case-Pins.stl</li> <li>R9M-Fan-Case-XT30.stl</li> <li>R9M-Fan-Case-Standoff.stl (2x)</li> <li>R9M-ExpressLRS-900Mhz.pdf</li> </ul> <p>or from Thingiverse</p>","title":"Download:"},{"location":"hardware/fan-mod/#controllable-fan-mod","text":"<p>Additionally to the fan you'll need one NPN Transistor (e.g. <code>2N4401</code>) or N-Channel MOSFET (e.g. <code>BS170</code> has built-in Shotky-Diode) and a resistor (200-3k7)</p> <p> </p>","title":"Controllable Fan Mod"},{"location":"hardware/fan-mod/#r9m2019-build-notice","text":"<p>The PB9 pad location on the R9M2019 module is a bit different. Please see the photo.</p> <p></p>","title":"R9M2019 Build notice"},{"location":"hardware/fan-mod/#2w-mod","text":"<p>WARNING</p> <p>Only do this if you are comfortable with modding hardware</p>  <p>In addition to the 3D printed Cover &amp; the Controllable Fan Mod you'll need:</p> <ul> <li>Fan + Heatsink <code>\"2507 25MM 25x25x13MM Hydraulic bearing Graphics card Cooling fan with heat sink 5V 12V m.2 SSD Fan with 2pin\"</code></li> <li>Thermalpad 0.5mm <code>\"1pc 100mmx100mmx0.5mm GPU Northbridge IC LED Chipset Heatsink Cooling Conductive Silicone Thermal Pad,100x100x0.5mm w/ 3.2W/M-K\"</code></li> </ul> <p>The screw heads are cut off to reduce height.</p> <p>   </p> <p>If you can see in picture 3, the 5v fan is connected to the power source of the module, so the fan is used with some overvoltage and spins with higher rpm... tested for a long time and should not be a problem for the fan. If you don't know how to allow the 2W in the firmware, don't do this mod!\ud83e\udd26\u200d\u2642\ufe0f</p>","title":"2W Mod"},{"location":"hardware/fan-mod/#here-are-some-makes","text":"<p>   </p>","title":"Here are some makes:"},{"location":"hardware/inverter-mod/","text":"<p></p> <ul> <li>To benefit from the higher bitrate of 400 kilobit per second using <code>OpenTX</code> you need to add a pullup resistor to the inverter of the serial port on the R9M 2018\ud83d\uddfb\ud83c\udd99</li> <li>Strongly suggested to be done for anybody looking for higher than standard packet rates using <code>ExpressLRS</code> \ud83d\udd2e</li> </ul>","title":"R9M Inverter Mod"},{"location":"hardware/inverter-mod/#identification","text":"<p>\u26a0\ufe0f This is only required for the 2018 version of the module which has a <code>ACCST</code> logo on the case \ud83d\udd0d </p>","title":"Identification"},{"location":"hardware/inverter-mod/#modification","text":"<p>Easy - connect a 300\u03a9 to 1000\u03a9 resistor between the <code>3.3V</code> and inverter pin as shown on the picture \ud83d\udc67</p> <p></p>","title":"Modification"},{"location":"hardware/inverter-mod/#transmitter-notes","text":"<ul> <li><code>X9D</code> only does 400 kbit/s and does not allow lowering the bitrate to 115200 bit/s - 400k Mod is not required.</li> <li><code>X10S Express</code> 400k Mod is not required.</li> <li><code>X10S</code> modification is required \ud83d\ude45 </li> <li><code>X12</code> modification is required \ud83d\ude45 </li> <li><code>QX7</code> allows configuration of the bitrate in the OpenTX hardware menu.  ELRS will work fine using 115200 bit/s but the modification is required for 400 kbit/s \ud83d\ude45\u200d\u2640\ufe0f</li> <li>The modification is not needed for <code>ACCESS</code> radios</li> </ul>","title":"Transmitter Notes"},{"location":"hardware/nuclear-hardware/","text":"<p></p>","title":"Nuclear Targets"},{"location":"hardware/nuclear-hardware/#nuclear-rx","text":"<p>The Nuclear RX is designed to be as small as possible, using the same software target as the DIY Nano RX, and assembled by JLCPCB. It uses the 2400MHz band and ExpressLRS firmware.</p> <p>Features: </p> <ul> <li>20x20 stack mounting with break-off tabs for compact applications  </li> <li>SMD Antenna</li> <li>Wi-Fi updating </li> <li>Up to 500Hz packet rate  </li> </ul> <p></p> <p>When you get your Nuclear RX, it will likely be on the latest release firmware. You'll probably have to update it to work with your TX. To update, follow the steps in the Wi-Fi updating page. Alternatively, you can use betaflight passthrough should work, but the boot jumper must be bridged while applying power to the RX.</p> <p>When building, use one of the <code>DIY_2400_RX_ESP8285_SX1280_via_X</code> targets. To use <code>via_wifi</code>, put your RX in binding mode, connect your computer to the RX's Wi-Fi, and hit upload.</p>    LED Status     Blinking Slowly Waiting for Connection   Fast Double Blink Binding Mode   Super Fast Blink Wi-Fi Updating Mode   Solid On Connected    <p>If for some reason the RX needs to be in boot mode, bridge the jumpers as shown here:</p> <p></p>","title":"Nuclear RX"},{"location":"hardware/nuclear-hardware/#nuclear-tx","text":"","title":"Nuclear TX"},{"location":"hardware/nuclear-hardware/#overview","text":"<p>The Nuclear TX is designed to be the same size as a FrSky slim module and use the same software target as the DIY Slim TX. It uses the 2400MHz band and ExpressLRS firmware. There is also a case that fits a full size JR module bay with the same PCB.</p>","title":"Overview"},{"location":"hardware/nuclear-hardware/#before-flight","text":"<p>If you ordered a Nuclear TX that wasn't fully assembled, these steps should help you finish it.</p>","title":"Before Flight"},{"location":"hardware/nuclear-hardware/#print-a-case","text":"<p>The latest version of the Nuclear TX STL files can be found here. Print the pieces in the orientation in the image and use support. Tree support in Cura works great. Keep in mind that PLA may melt if left in a hot car or in direct sunlight. </p>","title":"Print a case"},{"location":"hardware/nuclear-hardware/#assemble","text":"<p>Slap it together as seen below. Solder the wires to the pin header in the order in the picture, then slide it in from the outside. The header should press in with a little force. Add some glue on the inside to keep it from sliding out when removing it from your handset. Put the SMA pigtail in the hole in the top and screw it down. Use a wrench to make sure it doesn't come loose when you screw on your antenna. Plug the U.FL in to the module and route it under, and looping up around the side.  </p>","title":"Assemble"},{"location":"hardware/nuclear-hardware/#upload-firmware","text":"<p>When you get your Nuclear RX, it will likely be on the latest release firmware. You'll probably have to update it to work with the RX you have. To update, follow the steps in the Wi-Fi updating page. If your transmitter module ever becomes bricked from a bad upload, connect it with a serial adapter as shown here. MAKE SURE THE ADAPTER IS SET TO 3.3V; 5V WILL KILL THE MODULE! Use tweezers or solder to bridge the boot jumper while you power on the module to put it in boot mode. Use the target <code>DIY_2400_TX_ESP32_SX1280_E28_via_UART</code>. </p>","title":"Upload firmware"},{"location":"hardware/smd-antenna/","text":"<p></p> <p>Have you ever been frustrated that you can't finish a race because your receiver antenna got chopped? Have you ever wished you could build a quad without worrying about how to mount your antenna? If so, the SMD Antenna is for you!  </p> <p></p> <p>This perky little fellow is worse at receiving signals than his snaky brothers, but don't let that deter you! Because of the amazing range of ExpressLRS, he still gets all the range a racer could ever need. The SMD Antenna is available now on Happymodel PP/EP hardware and other 2.4GHz receivers. Take a look at the videos below to see what Mr. SMD can do for you.</p>","title":"SMD Antenna"},{"location":"hardware/smd-antenna/#range-tests","text":"<ul> <li>3km flight on 500hz: https://www.youtube.com/watch?v=kfa6ugX46n8</li> <li>Parking Garage on 500Hz: https://www.youtube.com/watch?v=Fr7CCeni2dY</li> <li>Range Comparison to Dipole: https://www.youtube.com/watch?v=A5w81n5qV1M</li> <li>RSSI Comparison Dipole: https://youtu.be/CnaEe7YZB-Q</li> </ul>","title":"Range Tests"},{"location":"hardware/smd-antenna/#maintenance","text":"<p>Note: The antenna is sorta fragile and can break off or be melted by a stray soldering iron. If this happens, you can save your receiver by soldering a U.FL/IPEX1 connector onto the pads like shown here. Just make sure the center pin has continuity with the filter at the other end of the trace, and no continuity with ground.  </p> <p></p> <p>Conversely, the SMD antenna can be soldered to regular U.FL footprints if you're brave.  </p> <p></p>","title":"Maintenance"},{"location":"hardware/spi-receivers/","text":"<p></p> <p>A few Flight Controllers and AIOs have been released with ExpressLRS receivers on-board using SPI instead of a regular UART. This means you can build a more compact and lightweight whoop or nano long range rig without the need for an external receiver. More of these flight controllers are coming into stores.</p> <p>Because the ExpressLRS code is \"baked-in\" to the flight controller firmware instead of a second microcontroller, these can not be updated the same way external receivers are. These SPI receivers will work always work with the ExpressLRS firmware of the same major version. That is, ExpressLRS 1.x.x and ExpressLRS 2.x.x need different Flight Controller firmware (Betaflight builds).</p>","title":"SPI Receivers"},{"location":"hardware/spi-receivers/#binding-procedure","text":"<p>There are two ways to bind the receiver, as shown below</p>","title":"Binding Procedure"},{"location":"hardware/spi-receivers/#button-binding","text":"<p>Put the receiver into bind mode using any of these procedures:</p> <ul> <li>\"Bind\" button in the Betaflight Configurator, Receiver Page (if can't be found, update the Betaflight firmware).</li> <li>using the CLI, type in <code>bind_rx</code> and press enter once.</li> <li>press the bind button on the flight controller.</li> <li>using the CLI, type in <code>set expresslrs_uid = 0</code>, press enter once, then save and reboot</li> </ul> <p>Execute elrs.lua in your handset and press the <code>Bind</code> button. The RX and TX should be now bound.</p> <p>Please mind the order, RX first, TX second.</p> <p>Video Tutorial (thanks to @JyeSmith):</p>","title":"Button Binding"},{"location":"hardware/spi-receivers/#binding-phrase","text":"<p>The binding phrase is hashed into 6 bytes represented as numbers. These 6 bytes are referred to as the UID bytes.  UID bytes are entered into the Betaflight CLI for binding. Please look below for instructions.  When building via ExpressLRS Configurator or via VS Code, note down the UID bytes from the build log. You can also use the  generator below to retrieve your UID bytes from your binding phrase.</p> <p></p>","title":"Binding Phrase"},{"location":"hardware/spi-receivers/#uid-byte-generator","text":"<p>Binding Phrase</p>    <p>UID Bytes <pre><code>\n</code></pre></p>","title":"UID Byte Generator"},{"location":"hardware/spi-receivers/#setting-binding-phrase","text":"<p>Go to Betaflight CLI and enter the following commands. (Enter your binding phrase above) <pre><code>\n</code></pre></p>     window.addEventListener(\"load\", (event) =&gt; {     initBindingPhraseGen();   });","title":"Setting Binding Phrase"},{"location":"hardware/spi-receivers/#rf-mode-adjustment","text":"<p>These AIOs with ExpressLRS SPI Receivers are set to use 500Hz as default. To adjust it, you will need to go into Betaflight CLI and use the following commands:</p> <pre><code>set expresslrs_rate_index = [your index]\nsave\n</code></pre> <p>Where <code>[your index]</code> corresponds to the following   :</p> <ul> <li>500Hz = 0</li> <li>250Hz = 1</li> <li>150Hz = 2</li> <li>50Hz = 3</li> </ul> <p>With the Updated Betaflight firmware, adjusting your packet rate from the Lua Script will also adjust the packet rate in the AIO.</p>","title":"RF Mode Adjustment"},{"location":"hardware/spi-receivers/#updating","text":"<p>As mentioned, you must flash a Betaflight firmware that's compatible with the ExpressLRS major version on your transmitter. ExpressLRS 1.x.x TX only works with Betaflight firmware for ExpressLRS 1.x.x, and upgrading the transmitter to ExpressLRS 2.x.x means flashing the flight controller with a different Betaflight version. If upgrading minor versions, such as from ExpressLRS 1.1.0 to 1.2.0 on the transmitter, no changes to the flight controller are needed although there may be bug fixes to the ExpressLRS Betaflight implementation as well.</p> <p>In preparation for this, you should save a copy of your <code>diff all</code> dump.</p> <p>Download the necessary binaries (zipped) from this Betaflight PR page. Extract the Hex File and, using Betaflight Configurator 10.8.0 (Nightly), flash the binary using the Load Firmware [Local] button found at the bottom right of the Firmware Flasher (Flight Controller in DFU Mode).</p> <p>Once flashed, you will need to paste in the <code>diff all</code> you have saved. Don't forget to type in <code>save</code> and press enter once done. Power cycle your flight controller, and you should be set. Review your Betaflight settings, and check your RC link.</p> <p>This procedure will only apply while Betaflight 4.3.0 is not yet released. Section will be updated appropriately for any changes in procedures.</p> <p>For more information, head over to the Betaflight PR page. We can also help out over at Discord!</p> <p>Content taken from the PR page \u2105 of @phobos-</p>","title":"Updating"},{"location":"hardware/supported-hardware/","text":"<p></p> <p>This is the hardware landing page! Welcome in. To navigate through this (large) subsection, use the sidebar on the left.</p> <p>These pages show information on certain modifications to hardware, and certain ELRS specific hardware. More and more manufacturers are coming up with their own take of the ExpressLRS Hardware and the list keeps growing.</p> <p>At the time of writing, here are the ExpressLRS-supported Transmitter Modules and Receivers, along with a few Flight Controllers and AIO boards.</p>","title":"Supported Hardware"},{"location":"hardware/supported-hardware/#24ghz-transmitter-modules","text":"","title":"2.4GHz Transmitter modules"},{"location":"hardware/supported-hardware/#happymodel-es24tx","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"Happymodel ES24Tx"},{"location":"hardware/supported-hardware/#namimnorc-flash","text":"<p>Flashing Guide</p>","title":"NamimnoRC Flash"},{"location":"hardware/supported-hardware/#betafpv-nano-24ghz","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"BetaFPV Nano 2.4GHz"},{"location":"hardware/supported-hardware/#ghost-tx","text":"<p>Flashing Guide</p> <p>Note: STLink first time flash, irreversible</p>","title":"Ghost TX"},{"location":"hardware/supported-hardware/#siyi-fm30","text":"<p>Flashing Guide</p>","title":"Siyi FM30"},{"location":"hardware/supported-hardware/#24ghz-receivers","text":"","title":"2.4GHz Receivers"},{"location":"hardware/supported-hardware/#happymodel-ep1-ep2","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"Happymodel EP1 &amp; EP2"},{"location":"hardware/supported-hardware/#happymodel-pp","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"Happymodel PP"},{"location":"hardware/supported-hardware/#namimnorc-flash_1","text":"<p>Flashing Guide</p>","title":"NamimnoRC Flash"},{"location":"hardware/supported-hardware/#betafpv-nano-24ghz_1","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"BetaFPV Nano 2.4GHz"},{"location":"hardware/supported-hardware/#mateksys-24ghz-receivers","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"MatekSys 2.4GHz Receivers"},{"location":"hardware/supported-hardware/#ghost-atto-receivers","text":"<p>Flashing Guide</p> <p>Note: STLink first time flash, irreversible</p>","title":"Ghost Atto Receivers"},{"location":"hardware/supported-hardware/#siyi-fr-mini","text":"<p>Flashing Guide</p> <p>Note: only guaranteed to work on the v3.0 of the receiver</p>","title":"Siyi FR Mini"},{"location":"hardware/supported-hardware/#900mhz-transmitter-modules","text":"","title":"900Mhz Transmitter Modules"},{"location":"hardware/supported-hardware/#frsky-r9m-inc-lite-lite-pro","text":"<p>Flashing Guide</p>","title":"Frsky R9M (inc. Lite &amp; Lite Pro)"},{"location":"hardware/supported-hardware/#happymodel-es900tx","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"Happymodel ES900TX"},{"location":"hardware/supported-hardware/#namimnorc-voyager","text":"<p>Flashing Guide</p>","title":"NamimnoRC Voyager"},{"location":"hardware/supported-hardware/#betafpv-nano-900mhz","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"BetaFPV Nano 900Mhz"},{"location":"hardware/supported-hardware/#900mhz-receivers","text":"","title":"900Mhz Receivers"},{"location":"hardware/supported-hardware/#frsky-r9-receivers","text":"<ul> <li>R9MM</li> <li>R9 Mini</li> <li>R9MX</li> <li>R9 Slim</li> <li>R9 Slim+</li> </ul> <p>Flashing Guide</p>","title":"Frsky R9 Receivers"},{"location":"hardware/supported-hardware/#jumper-r9-mini","text":"<p>Flashing Guide</p>","title":"Jumper R9 Mini"},{"location":"hardware/supported-hardware/#happymodel-es900rx","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"Happymodel ES900RX"},{"location":"hardware/supported-hardware/#namimnorc-voyager_1","text":"<p>Flashing Guide</p>","title":"NamimnoRC Voyager"},{"location":"hardware/supported-hardware/#betafpv-nano-900mhz_1","text":"<p>Flashing Guide</p> <p>Manufacturer Website</p>","title":"BetaFPV Nano 900Mhz"},{"location":"hardware/supported-hardware/#flight-controllers-with-onboard-expresslrs-receivers","text":"","title":"Flight Controllers with onboard ExpressLRS Receivers"},{"location":"hardware/supported-hardware/#happymodel-elrs-f4-2g4-aio","text":"<p>Manufacturer Website</p> <p>Note: SPI-based receiver. Doesn't need the ExpressLRS Configurator for updates. See this page for more info.</p>","title":"Happymodel ELRS F4 2G4 AIO"},{"location":"hardware/supported-hardware/#happymodel-crazyf4-elrs-aio-900mhz","text":"<p>Manufacturer Website</p> <p>Note: Receiver firmware can be updated using the ES915/868RX methods.</p>","title":"Happymodel CrazyF4 ELRS AIO 900Mhz"},{"location":"hardware/supported-hardware/#betafpv-f4-1s-12a-aio","text":"<p>Manufacturer Website</p> <p>Note: Receiver firmware can be updated using the Beta FPV Nano 2.4GHz methods</p>","title":"BetaFPV F4 1S 12A AIO"},{"location":"hardware/supported-hardware/#spracing-h7rf","text":"<p>Manufacturer Website</p> <p>Note: SPI-based receiver. Doesn't need the ExpressLRS Configurator for updates. See this page for more info.</p>","title":"SPRacing H7RF"},{"location":"hardware/supported-hardware/#diy-tx-modules","text":"<p>See this page here</p>","title":"DIY TX Modules"},{"location":"hardware/supported-hardware/#diy-receivers","text":"<p>See this page here</p>","title":"DIY Receivers"},{"location":"hardware/x9d-troubleshooting/","text":"<p></p> <p>For quite some time we had the impression that the X9D(+) radio works well with high baud rates, needed for ExpressLRS. However some users report it's not working as it should with ExpressLRS. For example:</p> <ul> <li>ExpressLRS Lua script just shows <code>Connecting...</code></li> <li>ExpressLRS Lua script shows unstable behavior, especially on the higher packet rates, showing values different from 0:['SELECTED PACKET RATE']</li> <li>Constant Telemety Lost/Telemetry Recovered Notification.</li> </ul>","title":"Troubleshooting the X9D(+)"},{"location":"hardware/x9d-troubleshooting/#so-what-could-be-wrong","text":"<p>It is possible that the X9D(+) radio also suffers from a slow inverter circuit that messes up the 400000 baud UART signals.</p> <p>As you maybe know, for the Taranis QX7(S) you can do the Crossfire inverter mod or select a lower baud rate in the Hardware menu (Page 6/7) of OpenTX to fix the issue.</p>","title":"So what could be wrong?"},{"location":"hardware/x9d-troubleshooting/#can-it-be-fixed","text":"<p>Well, the final verdict is not out yet, but the following may help to resolve the issue:</p> <ul> <li>Do a hardware mod as well on your X9D(+) as you can read all about here in PR# 59 for EdgeTX.</li> <li>This requires changing the 10k resistor <code>R82</code> to a 1k resistor. </li> <li>Download a OneBit_Status firmware using this OpenTX version, based on OpenTX 2.3.12 and enable <code>ONEBIT</code></li> </ul> <p> </p> <ul> <li>Select <code>115200 baud</code> using the above OpenTX version. (ExpressLRS will lock you out on 500Hz packet rate, but below that rate should be stable now.)</li> </ul> <p>The nice thing about the OpenTX build above is that it also adds two additional <code>Sync</code> lines to show the current OpenTX/UART behavior. This will show in your Model Setup (Page 2/11) where you select the external module type (where you selected CRSF to enable ELRS):</p> <p></p> <ul> <li>The first <code>Sync</code> line shows something like <code>L00002R04000u</code>. <code>L</code> and <code>R</code> indicates the microseconds of Lag and Rate.</li> <li>The <code>L</code> is how much OpenTX is trying to compensate to nail the rate you selected. (The closer to 0 the better)</li> <li>The <code>R</code> is just the Packet Rate you selected using the ExpressLRS Lua script.</li> <li>The second <code>Sync</code> line shows something like <code>G11 C00 F00</code>. This stand for <code>G</code> (good packets), <code>C</code> (CRC error), <code>F</code> (Framing error). The goal is to have zero errors here. (Don't forget to power your receiver so a link is established!)</li> </ul> <p>If this has helped you in any way (good or bad) with your X9D(+) radio, let us know on the ExpressLRS discord!</p>","title":"Can it be fixed?"},{"location":"info/crc-testing/","text":"<p></p> <p>After performing CRC tests using the CRC-13 it was found that CRC basically includes parity checking so adding a seperate parity check was wasteful. CRC checking has now been updated to 14-bit.</p> <p>The following tests were performed using the new CRC-14 bit implementation with a polynomial of 0x372B, which gives a hamming distance of 6 in a 57-bit range. What this means is that it can detect up to 5 randomly flipped bits a message that is 57 bits long.</p> <p>Three stress tests have been performed on the 50-bit data with CRC-14. The tests create random data in 7 bytes (the first byte only has the lower 2 bits set) then perform random bit flipping based on three styles.</p> <p>Bear in mind that the CRC is not in the data and so is not subject to bit flipping.</p>","title":"CRC Testing"},{"location":"info/crc-testing/#random-flipped-bits-within-14-bit-range","text":"<p>Anything over 14 is fairly useless as it will just flip bits back! <pre><code>1 : 0 out of 1000000 false positives, 0.000000%\n2 : 0 out of 1000000 false positives, 0.000000%\n3 : 0 out of 1000000 false positives, 0.000000%\n4 : 0 out of 1000000 false positives, 0.000000%\n5 : 0 out of 1000000 false positives, 0.000000%\n6 : 0 out of 1000000 false positives, 0.000000%\n7 : 0 out of 1000000 false positives, 0.000000%\n8 : 0 out of 1000000 false positives, 0.000000%\n9 : 0 out of 1000000 false positives, 0.000000%\n10 : 0 out of 1000000 false positives, 0.000000%\n11 : 0 out of 1000000 false positives, 0.000000%\n12 : 0 out of 1000000 false positives, 0.000000%\n13 : 0 out of 1000000 false positives, 0.000000%\n14 : 0 out of 1000000 false positives, 0.000000%\n15 : 0 out of 1000000 false positives, 0.000000%\n16 : 0 out of 1000000 false positives, 0.000000%\n17 : 0 out of 1000000 false positives, 0.000000%\n18 : 0 out of 1000000 false positives, 0.000000%\n19 : 0 out of 1000000 false positives, 0.000000%\n20 : 0 out of 1000000 false positives, 0.000000%\n21 : 0 out of 1000000 false positives, 0.000000%\n22 : 0 out of 1000000 false positives, 0.000000%\n23 : 0 out of 1000000 false positives, 0.000000%\n24 : 0 out of 1000000 false positives, 0.000000%\n25 : 0 out of 1000000 false positives, 0.000000%\n26 : 0 out of 1000000 false positives, 0.000000%\n27 : 0 out of 1000000 false positives, 0.000000%\n28 : 0 out of 1000000 false positives, 0.000000%\n29 : 0 out of 1000000 false positives, 0.000000%\n30 : 0 out of 1000000 false positives, 0.000000%\n</code></pre></p>","title":"Random flipped bits within 14-bit range"},{"location":"info/crc-testing/#flipped-bits-in-a-single-sequence-at-random-start-position","text":"<p>The number 1-30 is the number of consecutive bits that are flipped at a random starting position. <pre><code>1 : 0 out of 1000000 false positives, 0.000000%\n2 : 0 out of 1000000 false positives, 0.000000%\n3 : 0 out of 1000000 false positives, 0.000000%\n4 : 0 out of 1000000 false positives, 0.000000%\n5 : 0 out of 1000000 false positives, 0.000000%\n6 : 0 out of 1000000 false positives, 0.000000%\n7 : 0 out of 1000000 false positives, 0.000000%\n8 : 0 out of 1000000 false positives, 0.000000%\n9 : 0 out of 1000000 false positives, 0.000000%\n10 : 0 out of 1000000 false positives, 0.000000%\n11 : 0 out of 1000000 false positives, 0.000000%\n12 : 0 out of 1000000 false positives, 0.000000%\n13 : 0 out of 1000000 false positives, 0.000000%\n14 : 0 out of 1000000 false positives, 0.000000%\n15 : 0 out of 1000000 false positives, 0.000000%\n16 : 0 out of 1000000 false positives, 0.000000%\n17 : 0 out of 1000000 false positives, 0.000000%\n18 : 0 out of 1000000 false positives, 0.000000%\n19 : 0 out of 1000000 false positives, 0.000000%\n20 : 0 out of 1000000 false positives, 0.000000%\n21 : 0 out of 1000000 false positives, 0.000000%\n22 : 0 out of 1000000 false positives, 0.000000%\n23 : 0 out of 1000000 false positives, 0.000000%\n24 : 0 out of 1000000 false positives, 0.000000%\n25 : 0 out of 1000000 false positives, 0.000000%\n26 : 0 out of 1000000 false positives, 0.000000%\n27 : 0 out of 1000000 false positives, 0.000000%\n28 : 0 out of 1000000 false positives, 0.000000%\n29 : 0 out of 1000000 false positives, 0.000000%\n30 : 0 out of 1000000 false positives, 0.000000%\n</code></pre></p>","title":"Flipped bits in a single sequence at random start position"},{"location":"info/crc-testing/#randomly-flipped-bits","text":"<p>Interestingly this is where the hamming distance shows an any flipped bits less that HD6 are detected. Also this is where the built-in parity shows up as it detects the odd numbered bit flips. <pre><code>1 : 0 out of 1000000 false positives, 0.000000%\n2 : 0 out of 1000000 false positives, 0.000000%\n3 : 0 out of 1000000 false positives, 0.000000%\n4 : 0 out of 1000000 false positives, 0.000000%\n5 : 0 out of 1000000 false positives, 0.000000%\n6 : 101 out of 1000000 false positives, 0.010100%\n7 : 0 out of 1000000 false positives, 0.000000%\n8 : 134 out of 1000000 false positives, 0.013400%\n9 : 0 out of 1000000 false positives, 0.000000%\n10 : 129 out of 1000000 false positives, 0.012900%\n11 : 0 out of 1000000 false positives, 0.000000%\n12 : 123 out of 1000000 false positives, 0.012300%\n13 : 0 out of 1000000 false positives, 0.000000%\n14 : 116 out of 1000000 false positives, 0.011600%\n15 : 0 out of 1000000 false positives, 0.000000%\n16 : 106 out of 1000000 false positives, 0.010600%\n17 : 0 out of 1000000 false positives, 0.000000%\n18 : 113 out of 1000000 false positives, 0.011300%\n19 : 0 out of 1000000 false positives, 0.000000%\n20 : 118 out of 1000000 false positives, 0.011800%\n21 : 0 out of 1000000 false positives, 0.000000%\n22 : 131 out of 1000000 false positives, 0.013100%\n23 : 0 out of 1000000 false positives, 0.000000%\n24 : 102 out of 1000000 false positives, 0.010200%\n25 : 0 out of 1000000 false positives, 0.000000%\n26 : 111 out of 1000000 false positives, 0.011100%\n27 : 0 out of 1000000 false positives, 0.000000%\n28 : 159 out of 1000000 false positives, 0.015900%\n29 : 0 out of 1000000 false positives, 0.000000%\n30 : 116 out of 1000000 false positives, 0.011600%\n</code></pre></p>","title":"Randomly flipped bits"},{"location":"info/crc-testing/#ota-testing","text":"<p>A 5hr OTA soak test was done at RSSI -108dBm (2.4GHz, 500Hz) and branch https://github.com/ExpressLRS/ExpressLRS/commit/e3ddcc.  RC data bytes were hard coded 0xAA and checked for CRC14 pass/fail, and the number of bits flipped counted.</p> <p>The below table columns are the number of bits flipped, crc passed tally, crc failed tally. Where passed means a bad packet that passes the CRC check and would accepted by the RX. On the <code>0</code> row, <code>Passed</code> is good, <code>Failed</code> is where the data is good, but the CRC itself was changed by bit-flips. <pre><code>CRC | Passed | Failed\n0   | 5589423 | 55438\n1   | 0 | 68262\n2   | 0 | 81015\n3   | 0 | 37478\n4   | 2 | 32449\n5   | 0 | 18546\n6   | 0 | 20082\n7   | 1 | 12697\n8   | 0 | 12433\n9   | 0 | 9803\n10   | 1 | 8899\n11   | 0 | 7462\n12   | 0 | 6105\n13   | 1 | 4720\n14   | 0 | 3858\n15   | 0 | 3170\n16   | 1 | 2673\n17   | 0 | 2159\n18   | 1 | 1980\n19   | 0 | 1746\n20   | 1 | 1703\n21   | 0 | 1449\n22   | 0 | 1332\n23   | 0 | 1076\n24   | 0 | 833\n25   | 0 | 565\n26   | 0 | 454\n27   | 0 | 353\n28   | 0 | 288\n29   | 0 | 210\n30   | 0 | 168\n31   | 0 | 92\n32   | 0 | 39\n33   | 0 | 25\n34   | 0 | 5\n35   | 0 | 2\n36   | 0 | 0\n37   | 0 | 0\n38   | 0 | 0\n39   | 0 | 0\n</code></pre></p> <p>1hr soak test at -100dBm <pre><code>CRC | Passed | Failed\n0   | 1450923 | 10\n1   | 0 | 6\n2   | 0 | 34\n3   | 0 | 5\n4   | 0 | 10\n5   | 0 | 1\n6   | 0 | 3\n7   | 0 | 2\n8   | 0 | 0\n9   | 0 | 1\n10   | 0 | 1\n11   | 0 | 3\n12   | 0 | 0\n13   | 0 | 0\n14   | 0 | 0\n15   | 0 | 0\n16   | 0 | 0\n17   | 0 | 0\n18   | 0 | 1\n19   | 0 | 0\n20   | 0 | 0\n21   | 0 | 0\n22   | 0 | 0\n23   | 0 | 0\n24   | 0 | 0\n25   | 0 | 0\n26   | 0 | 0\n27   | 0 | 0\n28   | 0 | 0\n29   | 0 | 0\n30   | 0 | 0\n31   | 0 | 0\n32   | 0 | 0\n33   | 0 | 0\n34   | 0 | 0\n35   | 0 | 0\n36   | 0 | 0\n37   | 0 | 0\n38   | 0 | 0\n39   | 0 | 0\n</code></pre></p>","title":"OTA Testing"},{"location":"info/glossary/","text":"<p></p>","title":"Glossary"},{"location":"info/glossary/#glossary","text":"<p>Below you can find a list of terms you might not be sure about, as well as some common abbreviations:</p> <ul> <li><code>CRSF</code>: TBS Crossfire, more specifialy in our case most often refering to the communication protocol between TX and TX module and RX and FC respectively</li> <li><code>OTX</code>: OpenTX</li> <li><code>FW</code>: Firmware</li> <li><code>BL</code>: Bootloader, loads the FW</li> <li><code>S.Port</code>: SmartPort, sometimes referred to as <code>sport</code>. FrSky \"telemetry\" protocol. The <code>S.Port</code> also gets used for updating FrSky receivers.</li> <li><code>OTA</code>: Update your device <code>Over The Air</code> (wifi)</li> <li><code>MCU</code>: Micro Controller Unit, generally denotes an embedded system controller as opposed to big iron cpu</li> <li><code>OSD</code>: On Screen Display, refer to this page for instructions for setup in BF</li> <li><code>LQ</code>: Link Quality, percentage of expected packets received. Our preferred method of measuring the quality of the control link</li> <li><code>RSSI dBm</code>: Measure of power level measured in dBm. Basically, how strong the signal being received is</li> <li><code>RSSI</code>: Received Signal Strength Indicator, \"arbitrary\" scaled version of <code>RSSI dBm</code> or LQ. Signal Health: LQI and RSSI Explained</li> <li><code>Lua</code>: Means \"Moon\" in Portuguese. As such, Lua is the correct way to write and not all uppercase. The ExpressLRS Lua script can be installed on a OpenTX radio, to easily alter TX parameters like Packet rate, Telemetry ratio and Output power. But also shows if the radio (OpenTX) is communicating correctly with the module. ( e.g. 0:50, 0:150, 0:200 and so on.)</li> </ul> <p>To be continued.</p>","title":"Glossary"},{"location":"info/rx-scoreboard/","text":"<p></p> <p>The RX Scoreboard is a developer / troubleshooting feature that shows the outcome of every receiver packet cycle with a single character. Enable it with <code>-DPRINT_RX_SCOREBOARD</code> when compiling any RX environment and connect to the debug serial UART, usually the same as the CRSF output UART for most environments. </p> <p>\u26a0\ufe0f For that reason, it should not be enabled during normal RC control operation since it will get mixed in with real CRSF data sent to the FC.</p>","title":"RX Scoreboard"},{"location":"info/rx-scoreboard/#example-500hz-132-scoreboard","text":"<pre><code>RRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRR\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._RRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRTRRRRRRRRRRRRRRR_RRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRT\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRR_RRRRRRRRRRRRRRTRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRR__.RRRRRRRRRRRR\nRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRR.RRTRRRRRRRRRRRRRRRRRRRRRR\nRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRR\nRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._RRRRRRRRRRRRRRRRRRTRRRRRRRR.RRRRRRRRRRR\nRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRR\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTR\nRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRTRRRRsRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\nTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR.TRRRRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRR\nRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRR\nRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._R_RRRRRRRRRRRRRRRRTRRRRRRRR.RRRRRRRRRRRRRR\nRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRR\n</code></pre>","title":"Example 500Hz 1:32 Scoreboard"},{"location":"info/rx-scoreboard/#character-legend","text":"Character Meaning Description     R Receive \u2714\ufe0f A valid RC sticks or MSP packet was received which passes all validation   T Telemetry \u2714\ufe0f Telemetry was successfully transmitted   s SYNC \u2714\ufe0f A valid SYNC packet was received. Sync packets come about once every 4 seconds, or more frequently around a telemetry ratio or packet rate change   _ Missing \u274c No packet was received at all yet one was expected \ud83d\udc7b   . CRC \u274c A packet was received but failed CRC check","title":"Character Legend"},{"location":"info/rx-scoreboard/#name-origin","text":"<p>The term scoreboard originated from an Apache (web server) feature that would display the state of every worked as a single character in a text block. Thanks to them for the feature name and the dodecatillion web pages they've enabled serving.</p>","title":"Name Origin"},{"location":"info/signal-health/","text":"<p></p> <p>RSSI has become somewhat a generic term for how good a signal is, and every manufacturer can have their own scale, with most agreeing that \"100\" is the best, less than that is bad, and expect have RXLOSS at ???. This is an explanation of the signal metrics provided by ExpressLRS and how to understand their values.</p>","title":"Signal Health"},{"location":"info/signal-health/#two-types-of-signal-health","text":"<p>There are two main types of signal information available from ExpressLRS: RSSI and LQI</p> <ul> <li>RSSI - Received Signal Strength Indicator, this value indicates how loud \ud83c\udfba the reception is. RSSI must be above the sensitivity level to be understood. Units are dBm and start from 0 and go down as the volume gets lower (-130dBm hard limit).</li> <li>LQI - Link Quality Indicator, this value indicates how much of the conversation is being understood and ultimately all that matters. Units are percent, with 100% being every packet is received, and 0% means no packets are being received.</li> </ul> <p>Consider you're having a conversation in a quiet room. Your partner speaks loudly enough for you to hear, so the RSSI of their voice is above the sensitivity of your ears. You're going to understand the conversation because you're hearing every word. That's a 100% LQI-- you're receiving 100% of the words. Now imagine someone blows an air horn right in the middle of a sentence. The RSSI is still the same level, you still hear what you could make out at the same volume, you missed a word so the LQI is lower. The closer the volume of the conversation is to the background noise level in the room, the greater the chance is that you'll miss a word due to it getting mixed in with the background noise and lowering your LQI. Remember, LQI is all that matters. Your partner could shout as loud as they want but if you could hear every word anyway, the volume doesn't matter, you always heard every word.</p>","title":"Two Types of Signal Health"},{"location":"info/signal-health/#which-do-i-care-about","text":"<p>Both really. LQI is most important because you can't fly if you're not getting packets. RSSI is important because it tells you how close you are to the radio receiver not being able to receive packets at all. I'd say if you have just one, pick LQI, because that tells you what percentage of packets are getting through and you get to make the decision if it isn't enough. What you can't tell from LQI alone is when that number is going to drop off a cliff, and it could happen extremely fast because you hit the RSSI sensitivity limit.</p>","title":"Which do I care about?"},{"location":"info/signal-health/#rssi-sensitivity-limit","text":"<p>This is the lowest theoretical RSSI value that can be distinguished by the radio receiver. It is displayed in the ELRS.lua when you select the packet rate, because different packet rates and frequency bands have different sensitivity limits. Lower rates are more sensitive, -123dBm for 25Hz 915MHz up to -105dBm for 500Hz 2400MHz. This gives you the limit you know you can't fly below.</p>","title":"RSSI Sensitivity Limit"},{"location":"info/signal-health/#rssi-channel","text":"<p>RSSI and LQI are included already in the protocol used to communicate to the flight controller, so the \"RSSI Channel\" on the Receiver tab should be set to Disabled. RSSI_ADC  / \"Analog RSSI input\" on the Configuration tab should also be disabled.</p>","title":"RSSI Channel"},{"location":"info/signal-health/#available-rssi-osd-fields","text":"<ul> <li>RSSI dBm - This is the true RSSI value we've talked about here, and is available on Betaflight after 4.1 (?) and iNav after 2.6 (?)</li> <li>Link Quality - This is LQI discussed here, and has the same version requirements. Betaflight and iNav (LQ TYPE2 option) display add the RF Mode to this as well, e.g. <code>7:100</code> means mode 7 = 500Hz and 100% LQI.</li> <li>RSSI Value - Or sometimes just RSSI. This is the old undefined units of Signal Strength value that everyone is used to with no idea what value is good or what value is too bad. What value you'll actually see here varies, even on ExpressLRS, and is covered in the RSSI Value OSD field section. It is not recommended to use this field unless you have to (e.g. DJI).</li> </ul>","title":"Available RSSI OSD Fields"},{"location":"info/signal-health/#rssi-value-osd-field","text":"<p>What appears in the RSSI Value field is based on what is selected as the RSSI Channel as ExpressLRS also sends LQI and RSSI as channels (AUX11/ch15 and AUX12/ch16 respectively). It is better to use the dBm or LQ OSD fields instead of this one if you can. DJI users are forced to use this due to it being the only field supported by their OSD. Changes to RSSI Channel in Betaflight requires a reboot to take effect.</p> <ul> <li>Disabled is set as the \"RSSI Channel\" field in Betaflight - Displays RSSI dBm scaled as a percentage from -130dBm to 0dBm. Not recommended since what percentage of 130 is the Sensitivity Limit for your selected rate? Math!</li> <li>AUX11/ch15 is set as the \"RSSI Channel\" - Simply LQI although the value might be slightly off due to rounding.</li> <li>AUX12/ch16 is set as the \"RSSI Channel\" - Displays the RSSI dBm scaled as a percentage from the current Sensitivity Limit to -50dBm and is a decent indicator of how much range is left before the LQI cliff (0 here = Sensitivity Limit).</li> </ul> <p>In iNAV, the RSSI Value on the OSD is called RSSI (Signal Strength), and will always display 0. To show a filtered (by iNav) LQI in that field, set the rssi_source to protocol using the CLI with <code>set rssi_source = PROTOCOL</code>.</p>","title":"RSSI Value OSD field"},{"location":"info/signal-health/#what-about-snr","text":"<p>Wow look at you smarty pants! SNR stands for Signal to Noise ratio and compares RSSI dBm to the RF background noise level and is in dB units (not dBm). Notice it compares the background noise level and not the Sensitivity Limit. The value is of limited usefulness because the RF chip can only approximate the noise level and can only register a value so high above it leading to this value getting clipped. Add to that, LoRa modulation can actually receive data below the noise floor to some degree, so just ignore this number really, but positive values are better.</p>","title":"What about SNR?"},{"location":"info/signal-health/#how-far-can-i-go-on-xmw","text":"<p>Very far? This question is usually used in place of the actual question \"Will I get good signal where I fly?\" which is impossible to answer.</p> <p>ExpressLRS 2.4GHz can go over 40km at 250Hz 100mW on omnidirectional antennas with excellent LQI, or it can go 400m with less stellar LQI. By far the biggest factor in determining maximum range is direct line of sight. Blocking line of sight reduces RSSI dBm. A few trees or a building isn't going to keep you from flying due to ExpressLRS's excellent sensitivity even when line of sight isn't available, but range is reduced a bit for every physical object between you and the receiver. Piloting from an elevated position can eliminate some ground obstacles and provide a measurable boost in range.</p> <p>The second largest factor is interference. Interference is the clobbering of our packets by outside sources, such as wifi on 2.4GHz or other ISM transmissions on 868/915MHz, and is seen as a drop in LQI well before the sensitivity limit. Increasing TX power output is usually not the solution you'd expect, where each doubling in output power only might only add 10% to the usable range due to interference.</p>","title":"How far can I go on XmW?"},{"location":"info/signal-health/#team868team915-or-team24","text":"<p>Unfortunately, there is a misconception about the 2.4GHz range thanks to other radio protocols on the market. ExpressLRS uses LoRa, which has had some amazing results on 2.4GHz. Again, 40km on 100mW 250Hz on 2.4GHz. The advantages of 2.4GHz is that the antennas are 2.5x smaller than 915MHz antennas, and there's more spectrum for ExpressLRS to hop around in, opening up the air for more pilots at once. 868/915MHz does have increased penetration and is the ultimate king of long range flying, but penetration difference may not be as great as you think. The high sensitivity of ExpressLRS receivers allows them to fly places you wouldn't dream of flying FSK-based 2.4 receivers such as FrSky ACCST/ACCESS, FlySky AFHDS2A, Spektrum DMX, or Redpine.</p>","title":"#Team868/#Team915 or #Team2.4"},{"location":"info/signal-health/#rf-noise","text":"<p>We have all heard the stories of racers powering up his TBS crossfire full module at 2W and causing people to fail-safe during a race. This happens because the 868/915mhz band has limited bandwidth. The solution for this is to use a low power mode during races, so you do not blast anyone out of the sky. 2.4ghz does not have this issue. Flite Test has a world record of having 179 RC airplanes in the sky using 2.4 GHz.</p> <p>2.4GHz LoRa can also handle WiFi noise very well. Studies have been conducted with the coexistence of WiFi and LoRa bands. </p> <p>868/915 does not have to worry about WiFi signal but it does have to worry about cell towers and other RF noise. You are fighting against thermostats, fire systems, burglar systems and any other device running on that band.</p>","title":"RF noise"},{"location":"info/telem-bandwidth/","text":"<p></p> <p>Telemetry Burst describes the allocation of telemetry packets in ExpressLRS added in #472. There are two types of packets, LINK and DATA. LINK is the standard link statistics and is always available, and DATA is \"Advanced Telemetry\" which is telemetry coming from the flight controller and shares bandwidth with MSP transfers. Burst mode attempts to maintain a minimum rate of LINK packets and use the rest of the available telemetry slots for DATA.</p> <p>The LINK rate chosen was one every 512ms, roughly 2 per second but slightly higher to allow more rates to have an additional burst packet at lower ratios.</p>    Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)     500 1:128 256 3.9 1 78bps 78bps   500 1:64 128 7.8 3 156bps 234bps   500 1:32 64 15.6 7 312bps 547bps   500 1:16 32 31.2 15 625bps 1172bps   500 1:8 16 62.5 31 1250bps 2422bps   500 1:4 8 125.0 63 2500bps 4922bps   500 1:2 4 250.0 127 5000bps 9922bps   Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)   250 1:128 512 2.0 1 39bps 39bps   250 1:64 256 3.9 1 78bps 78bps   250 1:32 128 7.8 3 156bps 234bps   250 1:16 64 15.6 7 312bps 547bps   250 1:8 32 31.2 15 625bps 1172bps   250 1:4 16 62.5 31 1250bps 2422bps   250 1:2 8 125.0 63 2500bps 4922bps   Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)   200 1:128 640 1.6 1 31bps 31bps   200 1:64 320 3.1 1 62bps 62bps   200 1:32 160 6.2 2 125bps 167bps   200 1:16 80 12.5 5 250bps 417bps   200 1:8 40 25.0 11 500bps 917bps   200 1:4 20 50.0 24 1000bps 1920bps   200 1:2 10 100.0 50 2000bps 3922bps   Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)   150 1:128 853 1.2 1 23bps 23bps   150 1:64 426 2.3 1 47bps 47bps   150 1:32 213 4.7 1 94bps 94bps   150 1:16 106 9.4 3 188bps 281bps   150 1:8 53 18.8 8 375bps 667bps   150 1:4 26 37.5 18 750bps 1421bps   150 1:2 13 75.0 37 1500bps 2921bps   Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)   100 1:128 1280 0.8 1 16bps 16bps   100 1:64 640 1.6 1 31bps 31bps   100 1:32 320 3.1 1 62bps 62bps   100 1:16 160 6.2 2 125bps 167bps   100 1:8 80 12.5 5 250bps 417bps   100 1:4 40 25.0 11 500bps 917bps   100 1:2 20 50.0 24 1000bps 1920bps   Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)   50 1:128 2560 0.4 1 8bps 8bps   50 1:64 1280 0.8 1 16bps 16bps   50 1:32 640 1.6 1 31bps 31bps   50 1:16 320 3.1 1 62bps 62bps   50 1:8 160 6.2 2 125bps 167bps   50 1:4 80 12.5 5 250bps 417bps   50 1:2 40 25.0 11 500bps 917bps   Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst)   25 1:128 5120 0.2 1 4bps 4bps   25 1:64 2560 0.4 1 8bps 8bps   25 1:32 1280 0.8 1 16bps 16bps   25 1:16 640 1.6 1 31bps 31bps   25 1:8 320 3.1 1 62bps 62bps   25 1:4 160 6.2 2 125bps 167bps   25 1:2 80 12.5 5 250bps 417bps    <pre><code>// Source code for table generator\nint main(void)\n{\n  for (uint8_t rate=RATE_500HZ; rate&lt;RATE_4HZ; ++rate)\n  {\n    uint32_t hz = RateEnumToHz((expresslrs_RFrates_e)rate);\n    printf(\"| Air Rate | Telem Ratio | Telem Interval (ms) | Packets/second | Bandwidth (no Burst) | Bandwidth (Burst)\\n\");\n    if (rate == RATE_500HZ) printf(\"|---|---|---|---|---|---|\\n\");\n    for (uint8_t ratio=TLM_RATIO_1_128; ratio&lt;TLM_RATIO_ENUM_MAX; ++ratio)\n    {\n      uint32_t tlmRatio = TLMratioEnumToValue((expresslrs_tlm_ratio_e)ratio);\n      float telemPps = (float)hz / tlmRatio;\n      uint32_t telemInterval = 1000 * tlmRatio / hz;\n      uint32_t tlmBurst = TELEM_MIN_LINK_INTERVAL * hz / tlmRatio / 1000;\n      // Reserve one slot for LINK telemetry \n      if (tlmBurst &gt; 1)\n        --tlmBurst;\n      else\n        tlmBurst = 1;\n\n      printf(\"%u | 1:%u | %u | %.1f | %u | %.0fbps | %.0fbps\\n\",\n        hz, tlmRatio, telemInterval, telemPps, tlmBurst, telemPps*1/2*5*8,\n        5*8*telemPps*tlmBurst/(tlmBurst+1));\n    }\n  }\n\n  return 0;\n}\n</code></pre>","title":"Telemetry Bandwith"},{"location":"info/unit-testing/","text":"<p></p> <p>Assuming you have Visual Studio Code and platformio installed</p>","title":"Unit Testing"},{"location":"info/unit-testing/#windows-prerequisite","text":"<p>Install mingw-w64 from https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download</p> <p>In the windows search bar type <code>env</code> and select Edit the system environment variables</p> <p>Click the <code>Environment Variables...</code> button and in the <code>System variables</code> section double-click <code>Path</code> and click <code>New</code> then paste <code>C:\\Program Files (x86)\\mingw-w64\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\mingw32\\bin</code>. This path may be different on your system, but it is the path that mingw-w64 was installed to previously.</p>","title":"Windows Prerequisite"},{"location":"info/unit-testing/#running-the-tests","text":"<p>In VSCode with the ExpressLRS project open, click on the <code>New Terminal</code> button in the status bar</p> <p>Ensure the native platform is installed by entering <code>pio platform install native</code> in the terminal window.</p> <p>Now you can enter <code>pio test -e native</code> to run the tests.</p> <p>It also possible to use the pio module and select native/Advanced/Test in the target selection list.</p>","title":"Running the tests"},{"location":"quick-start/ardupilot-setup/","text":"<p></p>","title":"Ardupilot Setup"},{"location":"quick-start/ardupilot-setup/#ardupilot-serial-setup","text":"<p>Ardupilot Firmware must be 4.1 or higher to run CRSF protocol. As with any serial-based receiver, you need to attach the TX/RX pads to a UART on your flight controller, then enable Serial RX in the corresponding UART in Ardupilot. In mission planner, you will need to go to the <code>config tab -&gt; parameter tree</code> <pre><code>SERIALx_PROTOCOL = 23 (RCIN)\nRSSI_TYPE = 3 (ReceiverProtocol)\n</code></pre> our packet rate is different than CRSF packet rate, and ardupilot will keep on reporting the missmatch, but recently they have an option to suppress the report. Currently Ardupilot provide a way to suppress this notification with the parameter below. (this will not cause any effect to RC link or telemetry Link.) <pre><code>RC_OPTIONS turn on Bit 9th which is  \"Suppress CRSF mode/rate message for ELRS systems\".\n</code></pre></p> <p>Once you have set the parameter above, power-cycle the flight controller by disconnecting and reconnecting your battery and USB. Ardupilot should automatically run with ELRS, but if it fails, set <code>RC_PROTOCOL</code> parameter 9th bit to 1 (CRSF option)  and set the other parameter as below: <pre><code>SERIALx_PROTOCOL = 23 (RCIN)\nSERIALx_BAUDRATE = 115\nRSSI_TYPE = 3 (ReceiverProtocol)\n</code></pre></p>","title":"Ardupilot Serial Setup"},{"location":"quick-start/ardupilot-setup/#ardupilot-flightmodes","text":"<p>Ardupilot default flightmodes channel is channel 8, but ELRS 8 position channel is on channel 12 (in hybrid switchMode). you will need to set your handset to use channel 12 as flightmodes and set Ardupilot parameter: <pre><code>FLTMODE_CH=12\n</code></pre></p> <p>if you are using WideSwitch mode (only available in elrs V2 and above), you can use any channel for your 8 flightmode selection (beside channel 15 which is LQ and channel 16 which is RSSI).</p>","title":"Ardupilot Flightmodes"},{"location":"quick-start/ardupilot-setup/#ardupilot-rssi-and-link-quality","text":"<p>To get RSSI and LQ shown in OSD (in %) set: <pre><code>RSSI_TYPE = 3 (ReceiverProtocol)\n</code></pre></p> <p>and go to your OSD tab, and place your RSSI and LQ element where you want them to be.</p> <p>Happy Flying! </p>","title":"Ardupilot RSSI and Link Quality"},{"location":"quick-start/binding/","text":"<p></p> <p>Binding can be done with either a hard coded unique binding phrase or in a more traditional way where you put the receiver and transmitter into bind mode, and they link up. There is no reason to use traditional binding if you're flashing both your TX and RX firmware anyway. If you used a bind phrase in your user defines, there is no need to read this article. Proceed to the next section. If not, here is how to bind an ELRS TX and RX.</p>","title":"Binding ExpressLRS"},{"location":"quick-start/binding/#unique-phrase","text":"<p>You need to have a unique binding phrase in the <code>user_defines.txt</code> file or entered in the \"Custom Binding Phrase\" box in the Configurator.  After flashing your TX and RX, they will bind automatically. Is my binding phrase a secret?</p> <pre><code>-DMY_BINDING_PHRASE=\"default ExpressLRS binding phrase\"\n</code></pre>","title":"Unique Phrase"},{"location":"quick-start/binding/#traditional-binding","text":"<p>For traditional binding, the binding phrase must be commented out in user_defines on the RX.</p> <ol> <li>Power off your transmitter</li> <li>Plug in and unplug your receiver three times</li> <li>Make sure the LED is doing a quick double blink, which indicates the receiver is in bind mode</li> <li>Use the [BIND] button on the Lua script, which sends out a binding pulse</li> <li>If the receiver has a solid light, it's bound!</li> </ol> <p>Important: If the RX firmware has a bind phrase, the RX will never enter binding mode using the above procedure. It must be flashed without a binding phrase to do traditional binding. Why would you not use a bind phrase though if you're already having to flash the RX anyway? </p>","title":"Traditional Binding"},{"location":"quick-start/binding/#connection-check","text":"<p>Go to the <code>Telemetry Page</code> of your model setup and try to find new sensors. If the telemetry data shows up then you are connected!</p>","title":"Connection Check"},{"location":"quick-start/firmware-options/","text":"<p></p> <p>This page aims to explain which options to set on the ExpressLRS Configurator for a particular Hardware. It helps guide you through which options you should enable for your purposes or which options should be left at default.</p> <p>Some of these options are present on both the Tx and Rx Targets. It is important that these options match to both the TX module and receiver in order for them to bind. <code>team2400</code> and <code>team900</code> also share a few options and some options are unique to that frequency band. Shown below are common options available on <code>team2400</code> and <code>team900</code> TXes respectively.</p> <p></p> <p></p>","title":"Firmware Options"},{"location":"quick-start/firmware-options/#regulatory-domains","text":"<p><pre><code>Regulatory_Domain_AU_915\nRegulatory_Domain_EU_868\nRegulatory_Domain_FCC_915\nRegulatory_Domain_ISM_2400\n</code></pre> This is a relatively simple one - enable whatever regulatory domain you are in. <code>EU 868</code> is compliant to the frequency but is not LBT compliant \ud83d\udc42 . Every other band is near compliant \ud83d\udc7f  but may not be fully compliant for your regulatory domain. </p>","title":"Regulatory Domains"},{"location":"quick-start/firmware-options/#binding-phrase","text":"<p>This step is simple but important. Both the TX and RX NEED to have the same binding phrase or ExpressLRS WILL NOT WORK. Anyone using the same binding phrase as you will be able to control your model, so be unique. Set something memorable, and limit to alphanumeric phrases conforming to the Latin alphabet. Receivers flashed with firmware builds that do not have binding phrase enabled will support and require the traditional binding method. \ud83d\udcdc </p>","title":"Binding Phrase"},{"location":"quick-start/firmware-options/#performance-options","text":"<p><pre><code>NO_SYNC_ON_ARM\n</code></pre> no sync on arm doesn't transmit sync packets while armed. This is useful for racing as there is less time &amp; packets wasted \ud83d\uddd1\ufe0f on sending sync packets. HOWEVER if you are doing serious long range \u26f0\ufe0f, keep this commented because in the case of a sustained failsafe, link can not be regained while armed.</p> <p>AUX1 is the channel ExpressLRS uses to detect \"ARMED\", and this feature assumes that a low value of the arm switch is disarmed, and a high value is armed. OpenTX can invert your switch if you prefer it to be mechanically inverted. It may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion.</p> <p><pre><code>FEATURE_OPENTX_SYNC\n</code></pre> This option enables lower latency \ud83c\udfc3\u200d\u2642\ufe0f from the OpenTX radio to the TX and should be kept enabled. To get the full benefit of the option, you should be running an OpenTX version with CRSFShot or Mixer Sync enabled.</p> <p><pre><code>USE-500HZ\n</code></pre> This enables 500Hz mode for 2.4 GHz RXes and TXes. The drawback is that you have to give up 25Hz mode to add 500Hz mode. It requires OpenTX 2.3.12 or Newer, EdgeTX or a Radio firmware that has CRSFShot or Mixer Sync. Note: Since version 1.0.0-RC9, this option is now always enabled and in turn, 25Hz has been dropped/removed.</p>","title":"Performance Options"},{"location":"quick-start/firmware-options/#extra-data","text":"<p><pre><code>HYBRID_SWITCHES_8\n</code></pre> Changes how the AUX channels are sent over the air. The default option is Normal Mode with 8x 2-position low-latency switches. Enabling <code>HYBRID_SWITCHES_8</code> changes this to 1x 2-pos + 6x 7-pos + 1x 16-pos, with only the 2-position being low-latency. In Normal Mode, all switches are sent with every packet; while in Hybrid Mode, only AUX1 is sent with every packet and the rest are rotated through. Note: The switch mode MUST match between the TX and RX. A detailed explanation of the differences between the two options can be found in the Switch Modes page.</p> <p><pre><code>ENABLE_TELEMETRY\n</code></pre> Enable advanced telemetry support. This option must be enabled on both TX and RX. The following telemetry messages are supported:</p> <ul> <li>GPS</li> <li>BATTERY_SENSOR</li> <li>ATTITUDE</li> <li>DEVICE_INFO</li> <li>FLIGHT_MODE</li> <li>MSP_RESP</li> </ul> <p>Note 1: Increase the telemetry rate with the ExpressLRS lua script. Increase the rate until the sensor lost warnings go away. It is normal to set it up to 1:16 with a 200 Hz refresh rate.</p> <p>Note 2: It must be enabled together with HYBRID_SWITCHES_8.</p> <p>With this unchecked/disabled, you will only get the basic RC Link Telemetry like 1RRS (RSSI dbm), RQLY (LQ) etc.</p> <p>Tip. You can have this option enabled in the Firmware Configuration, but set TLM Ratio to OFF in the ELRS Lua Script when you don't need advanced telemetry (like when racing). Should you need the telemetry (freestyle or medium-to-long-range flying), flip TLM Ratio back to your favorite ratio, like 1:16 or 1:8.</p> <p><pre><code>TLM_REPORT_INTERVAL_MS\n</code></pre> It makes the TX module send the telemetry data to OpenTX to the interval you set. This stops the telemetry lost warnings when running a high telemetry ratio, or low rates like 50hz.</p> <p>Default value is 320LU. If you want to change that you have to suffix your milliseconds value with LU. For example, in order to specify 100 ms telemetry update rate you have to enter it like this: 100LU.</p> <p>Typically, you want to keep 320LU value for OpenTX based radios, and 100LU for ErskyTx ones.</p> <p>Tip: only check this if you're changing the value. No need to enable it if you'll be using the default 320LU value</p>","title":"Extra Data"},{"location":"quick-start/firmware-options/#other-options","text":"<p><pre><code>JUST_BEEP_ONCE\nDISABLE_STARTUP_BEEP\nMY_STARTUP_MELODY=\"&lt;music string&gt;|&lt;bpm&gt;|&lt;semitone offset&gt;\"\n</code></pre> For TXes like the R9M, this sets if the TX only beeps one-time, not beep at all or play custom a startup song. By default it is set to play the ExpressLRS Startup Tune \ud83c\udfbc , but if you don't prefer it, or simply want to go stealthy, enable any of these options. \u2716\ufe0f</p> <p>For all your customization needs, use <code>MY_STARTUP_MELODY</code> to define your own startup melody using either the BlHeli32 syntax or RTTL.  The BlHeli32 Synatax has the required parameters <code>music string</code> and <code>bpm</code>, and <code>semitone offset</code> is optional to transpose the entire melody up or down by the defined amount of semitones. Example BlHeli32 melodies are available on Rox Wolfs youtube channel, some experimentation may be required though.  To write your own melody, this (Sheet Music 101) and this (BLHeli Piano) are useful resources.</p> <p>The RTTL Syntax is the same as used in old mobil phones for ringtones and some examples of it can be found here, where you can search through many existing RTTL melodies.</p> <p><pre><code>UNLOCK_HIGHER_POWER \n</code></pre> Majority of the ExpressLRS modules maxes out at 250mW. With this option, higher power levels can be unlocked on the modules that supports it. However, it is imperative that you have taken measures to provide ample cooling to the module's internals through the use of a Fan Mod. This specifically applies to the R9M, which, from factory, supports a higher power level up to 1W; but because ExpressLRS runs at a much higher duty cycle, it taxes the circuity and thus produces heat much earlier. To keep it stable, cooling should be implemented. Without any cooling, you run the risk of ending up with a red paperweight.</p> <p><pre><code>UART_INVERTED\n</code></pre> This only works with ESP based TXes (will not work with modules without built-in inversion/uninversion), but enables compatibility with radios that output inverted CRSF, such as the FrSky QX7, TBS Tango 2, RadioMaster TX16S. You want to keep this enabled in most of the cases. If your radio is T8SG V2 or you use Deviation firmware turn this setting off.</p>","title":"Other Options"},{"location":"quick-start/firmware-options/#receiver-only-options","text":"<p></p> <p></p> <p>Note: Configuration of the Receivers should match the configuration of the Transmitter Module for Sync/Binding to happen between devices.</p> <p>The explanation of the options for the Transmitter Modules also apply for the Receivers.</p> <p>But here's a few Receiver-specific Options you can configure:</p> <p><pre><code>LOCK_ON_FIRST_CONNECTION\n</code></pre> RF Mode Locking - When the RX is waiting for a connection, it cycles through all available rates waiting for a connection on each one. By default, ExpressLRS will go back to this mode after a disconnect (failsafe). If LOCK_ON_FIRST_CONNECTION is used, ELRS will not cycle after a disconnect, but instead just stay on whatever rate the last connection was. This makes connection re-establishment quick, because the RX is always listening at the proper rate. This is generally what everyone wants, but there is utility in being able to switch the TX to the lowest rate to get more range to re-establish a link with a downed model, which can't happen if the RX is locked at the previous rate. When cycling through the rates, the RX starts with the fastest packet rate and works down to the slowest, then repeats. It waits PACKET_INTERVAL * PACKS_PER_HOP * HOP_COUNT * 1.1 at each rate. Example: 4ms * 4 * 80 * 1.1 = 1.408s for 250Hz. The duration is extended 10x if a valid packet is received during that time. Even with LOCK_ON_FIRST_CONNECTION, the rate can be changed by changing the TX rate using ELRS.lua while connected, or by power cycling the RX.</p> <p><pre><code>AUTO_WIFI_ON_INTERVAL\n</code></pre> \u26a0\ufe0f Must be defined if you plan to update your RX over wifi without using a button on the RX \u26a0\ufe0f This will automatically turn the wifi \ud83d\udcf6 on for any module that has an ESP8285 on it if no TX connection is established after N seconds from boot (Factory Firmware of the HappyModel receivers set this to the previous default of 20s. RC8 has increased the interval to 30s). This enables pushing firmware updates to the RX by connecting to its wifi network and visiting http://10.0.0.1.</p> <p><pre><code>USE_DIVERSITY\n</code></pre> Enable antenna-switching diversity for Receivers that support it.</p> <p><pre><code>USE_R9MM_R9MINI_SBUS\n</code></pre> This does not turn on SBUS protocol it simply changes the pin used for communication from those two side pins (A9 and A10) to use the pin labeled \"SBUS\" on the RX, which is inverted. This is useful for F4 FCs which only have an inverted receiver input UART RX. \ud83d\udd3c. This is only one way, so you lose the telemetry downlink to your radio as well as passthrough flashing. Enabling this turns on CRSF protocol output on the S.BUS \ud83d\ude8c pin on your R9MM/R9Mini. set serialrx_inverted = ON may also be needed within Betaflight \ud83d\udc1d for compatibility</p> <p>For a complete list of User Defines, head over to the User Defines page.</p> <p>Done! It's time to flash the firmware on your transmitter</p>","title":"Receiver Only Options"},{"location":"quick-start/getting-started/","text":"<p></p> <p>Welcome to the ELRS Quick Start Guide!</p> <p>Please use the Navigation Bar at the bottom of each page for a more step-by-step approach, or use the Navigation Menu at the left to get to a Hardware-specific Guide.</p> <p>Longer pages have a Table of Contents menu found on the right hand side of the page.</p> <p>We hope these pages will help you get started with ExpressLRS and experience one of the best and innovative RC Link in the hobby. </p>","title":"Getting Started"},{"location":"quick-start/installing-configurator/","text":"<p></p> <p>There are two ways to build &amp; flash ExpressLRS. The recommended way is to use ExpressLRS Configurator. For advanced users who want to modify the code, you can setup the development toolchain.</p>","title":"Installing Configurator"},{"location":"quick-start/installing-configurator/#configurator-setup","text":"<p>Download the latest ExpressLRS Configurator application for your platform, following the instructions written by jurgelenas.</p> <p></p> <p>The targets for each of the supported hardware can be seen on the individual device pages. Use the navigation menu on the left to get to the specific hardware page.</p> <p>On the next page, you will find the different Firmware Options you can set along with their explanations.</p>","title":"Configurator Setup"},{"location":"quick-start/pre-1stflight/","text":"<p></p> <p>Prior to your first ExpressLRS flight, you may want to do a few tweaks to your setup to ensure a fun and trouble-free ExpressLRS experience!</p>","title":"Pre-first Flight Checks"},{"location":"quick-start/pre-1stflight/#modes","text":"<p>By default, ExpressLRS uses one-bit switches for the AUX channels. This means a three-position switch will only send two positions (fully off, or 1000, and fully on, or 2000) to Betaflight/iNav on the AUX channels. Set your modes appropriately if you are using one-bit switches, or enable HYBRID_SWITCHES_8 for expanded position options. For more information, read the switch modes page. </p>","title":"Modes"},{"location":"quick-start/pre-1stflight/#rssi-and-link-quality","text":"<p>To get RSSI and Link Quality displayed in the OSD, set RSSI Channel to \"Disabled\" in the Receiver tab of the Betaflight/iNav Configurator, and RSSI_ADC should be disabled on the Configuration tab. Both of these are the default. On the OSD menu, use the Link Quality and RSSI dBm value elements (not \"RSSI Value\"). iNav have put this in the <code>CRSF RX Statistics</code> section.</p> <p></p> <p>If you wish to enable the rssi dBm warning, you'll have to change the alarm level using <code>set osd_rssi_dbm_alarm = -100</code> in CLI. A sensible value is 5-10 higher than the sensitivity shown in the ELRS.lua for the packet rate (e.g. 250Hz=-108, so -103 to -98 for the alarm). If using DJI Goggles, you're required to use \"RSSI Value\" as the OSD element. Therefore you have to decide between LQ or RSSI, by selecting either AUX11 (LQ) or AUX12 (RSSI) as RSSI Channel on the Receiver tab. More information about signal metrics is found in this great article on signal health.</p>","title":"RSSI and Link Quality"},{"location":"quick-start/pre-1stflight/#bench-test","text":"<p></p> <p>Shown above is a Bench Test to determine if you're getting a good signal from your radio. This aims to provide you information on whether you should check your antennas (particularly the R9's Super 8) or you have good hardware overall. </p> <ul> <li>Set your ExpressLRS module to just 10mW using the Lua script. The packet rate doesn't matter much here.</li> <li>Put your radio 1m (3ft) from your receiver and power it up. Make sure the receiver and TX module antennas are oriented in the same way. (You might want to disconnect your vtx/air unit temporarily, put vtx on pit mode or have a fan blowing on it).</li> <li>Using your OSD or the Telemetry Page of your radio, take note of the RSSI dbm or the 1RSS telemetry data.</li> </ul> <p>On the 900Mhz hardware, a -20dbm or thereabouts is a good indication your hardware is in working order. On the 2.4Ghz hardware, around -40dbm to -30dbm should be good. If you're getting lower numbers than these, here are a few things you could check:</p> <ul> <li>The ExpressLRS module antenna could be loose. On some 3D printed module cases, the print may be too thick at the part where the pigtail's RP-SMA/SMA end would be attached; if so, tighten the nut on the RP-SMA/SMA to give the antenna some more space to get tightened up.</li> <li>The antenna pigtail may be damaged or not connected properly to the module's mainboard.</li> <li>On receivers using an SMD antennas, expect lower values than those equipped with wire antennas. If the receiver with the SMD antenna has heat shrink, enclosed in a whoop canopy, surrounded with carbon parts or buried inside a plane/fixed wing, expect some more attenuation of the signal.</li> <li>The Super 8 antenna from Frsky, which most of the R9Ms came with, are notorious for being faulty or would degrade from just a few weeks use. Replace it or as a temporary fix, solder all around the junction where the coax shielding and the RP-SMA meet. Another failure point is the connection of the coax to the active elements itself. It would seem okay, but due to twisting of the antenna, the connection could be severed.</li> </ul> <p></p> <p>Super8 Antenna's common point of failure</p> <ul> <li>Check if there aren't any missing components in your receivers, like the RF filter (can be found near the antenna or ufl). Also check if the SMD antenna is not broken or damaged and it's soldered in properly.</li> </ul> <p></p> <ul> <li>Most DIY modules require moving the 0 ohm resistor on the E28 from the PCB antenna side towards the UFL side. A solder bridge will work just fine as well, but make sure it is on the correct pads.</li> <li>Swap out antennas on receiver and/or the TX module; Most ExpressLRS receiver antennas use IPEX 1/UFL connectors and as long as the frequency tuning of the antenna is appropriate for the frequency you're in, it should work. You can also use old 2.4GHz WiFi Router antennas for your 2.4GHz modules, but avoid those that are dual-band. Also make sure that the connector on the antenna is the appropriate one (RP-SMA on R9 modules; SMA on most off-the-shelf ExpressLRS modules).</li> </ul>","title":"Bench Test"},{"location":"quick-start/pre-1stflight/#blackbox","text":"<p>Blackbox is handy for evaluating the performance of the RF link for a flight. Set your BB to debug mode <code>RC_SMOOTHING_RATE</code>, which will capture the rate that Betaflight is receiving RC Packets from the RX.</p>","title":"Blackbox"},{"location":"quick-start/pre-1stflight/#telemetry","text":"<p>Initially ExpressLRS had very limited telemetry support but with Version <code>1.0.0-RC1</code> this changed and full telemetry was added as optional feature. The default setting only includes the link status message that includes the RSSI and Link quality.</p> <p>To receive all messages the feature telemetry has to be enabled in the user defines. It's possible to flash your TX module with telemetry support enabled and use it with a RX without telemetry enabled. So you can flash certain receivers with telemetry support and others without it and use it with the same TX module.</p> <p>The RX transmits a subset of telemetry it receives from the flight controller. Disabling certain messages only works if the flight controller firmware does support it. For Betaflight this is possible with the telemetry_disabled_* cli settings:</p> <pre><code># Disable Attitude telemetry item\nset telemetry_disabled_pitch = ON\nset telemetry_disabled_roll = ON\nset telemetry_disabled_heading = ON\n# Disable Battery telemetry item\nset telemetry_disabled_voltage = ON\nset telemetry_disabled_current = ON\nset telemetry_disabled_fuel = ON\n# Disable GPS telemetry item\nset telemetry_disabled_altitude = ON\nset telemetry_disabled_lat_long = ON\nset telemetry_disabled_ground_speed = ON\nset telemetry_disabled_heading = ON\n# Disable Flight Mode telemetry item (BF &gt;4.2.9)\nset telemetry_disabled_mode = ON \n</code></pre> <p>Since telemetry messages are sent with low priority it takes some time to transmit the data. The telemetry rate in the lua settings script controls how often a telemetry message should be sent. So a ratio of 1:2 means that every second message is a telemetry message, so the telemetry data is transferred very fast. A ratio 1:64 means that only one of 64 messages is a telemetry message and so the transfer happens much slower.</p> <p>The refresh rate also impacts the transfer speed. 50 Hz is slower compared to 200 Hz. So if you need fast a fast telemetry update rate choose high refresh rate, and a ratio that favors telemetry messages e.g. 200 Hz and 1:16 usually works good. For detailed information on telemetry bandwidth at different rates and ratios, see this page on telemetry bandwidth.</p> <p>To finish the telemetry setup open the telemetry page on your transmitter and select \"Discover new sensors\" and wait for the list to fill. You will notice that there is a * sign for each row. This star indicates that this telemetry sensor was just updated.  If you see a row that does not change, and the name of the row is in square brackets it means that this sensor was not updated for some time.</p> <p>The first values (including RSSI and link quality) should always be updated (flashing stars). If this does not happen multiple times per second the transmitter will issue a \"telemetry warning\". To prevent this warning use the setting TLM_REPORT_INTERVAL_MS.</p> <p>It should look like this (and if it does not there is something wrong with your setup):</p> <p></p> <p>The remaining values are updated at a different rate (depending on refresh rate and tlm ratio). So if you use 50 Hz and 1:64 it will happen really slow, and the update takes multiple seconds for each sensor:</p> <p></p> <p>If you use 200Hz and 1:2 tlm ratio the stars will not even blink because the update happens so fast:</p> <p></p>","title":"Telemetry"},{"location":"quick-start/pre-1stflight/#msp","text":"<p>To configure betaflight from your transmitter it's possible to use the betaflight lua scripts.  This requires the telemetry feature enabled for the RX+TX. If the telemetry page of OpenTx does not show regular updates for all sensors the LUA script will also not work.</p> <p>Mavlink is not supported and currently not planned to be added.</p> <p>To get a responsive UI configure ExpressLRS for fast data transfer so make sure to use something like <code>200Hz/500Hz</code> with <code>1:2</code> tlm and a serial baud rate of <code>400000</code>. Currently MSP is limited to <code>50Hz</code> on <code>115200</code> Baud and does not work with <code>500 Hz</code> refresh rate. The initial VTX tables download does take long - but is cached after that. </p> <p>If you get a \"retrying\" message while saving changes it means that the lua script did not receive a response fast enough. But the change usually still goes through so try reloading the page to check if the change was saved. With the recommended settings this does not happen but with slower settings it could happen.</p> <p>Done. Go Fly!</p>","title":"MSP"},{"location":"quick-start/rx-betafpv2400/","text":"<p></p>","title":"Flashing BetaFPV Nano 2.4G"},{"location":"quick-start/rx-betafpv2400/#flashing-via-passthrough","text":"<p>Target: <code>BETAFPV_2400_RX_via_BetaflightPassthrough</code></p> <p>Make sure you have wired your receiver properly. Rx pad on the Receiver wired up to a Tx pad on the FC, and the Tx pad on the Receiver wired up to an Rx pad on the FC. Also make sure you have setup your FC firmware to use CRSF Protocol, and that the UART is not inverted or running in half duplex.</p> <p>If the receiver gets powered up when you connect the FC to USB, you will need to Press and Hold the button on the receiver, connect USB and let go of the button once the LED stopped blinking and goes SOLID.</p> <p>If the receiver needs a LiPo attached to get powered up, then Press and Hold the button on the receiver, attach a LiPo, then let go once the LED in the receiver stopped blinking and goes SOLID. Then connect your FC to USB.</p> <p>These procedures will not be needed in subsequent passthrough flashing. This is only needed on the first time you'd update the receiver from its factory firmware.</p> <p>Select the corresponding target in the ExpressLRS Configurator, set your Firmware Options and then click Build and Flash. For first time flashing/updating, it would normally take a while.</p> <p>A <code>Success</code> message will be shown once the process is complete.</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-betafpv2400/#flashing-via-wifi","text":"<p>Target: <code>BETAFPV_2400_RX_via_WIFI</code></p> <p>With the receiver wired properly to your FC, select the correct target and set the Firmware Options in the ExpressLRS Configurator.</p> <p>Build the firmware. Once done, it should open a new window where the <code>BETAFPV_2400_RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>BETAFPV_2400_RX-&lt;version&gt;.bin</code> is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on the Update button and the firmware file will be uploaded and the update process should commence.</p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Flashing via WiFi"},{"location":"quick-start/rx-betafpv2400/#flashing-via-ftdi","text":"<p>Target: <code>BETAFPV_2400_RX_via_UART</code></p> <p>Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"Flashing via FTDI"},{"location":"quick-start/rx-betafpv900/","text":"<p></p>","title":"Flashing BetaFPV Nano 900Mhz"},{"location":"quick-start/rx-betafpv900/#flashing-via-passthrough","text":"<p>Target: <code>BETAFPV_900_RX_via_BetaflightPassthrough</code></p> <p>Make sure you have wired your receiver properly. Rx pad on the Receiver wired up to a Tx pad on the FC, and the Tx pad on the Receiver wired up to an Rx pad on the FC. Also make sure you have setup your FC firmware to use CRSF Protocol, and that the UART is not inverted or running in half duplex.</p> <p>If the receiver gets powered up when you connect the FC to USB, you will need to Press and Hold the button on the receiver, connect USB and let go of the button once the LED stopped blinking and goes SOLID.</p> <p>If the receiver needs a LiPo attached to get powered up, then Press and Hold the button on the receiver, attach a LiPo, then let go once the LED in the receiver stopped blinking and goes SOLID. Then connect your FC to USB.</p> <p>These procedures will not be needed in subsequent passthrough flashing. This is only needed on the first time you'd update the receiver from its factory firmware.</p> <p>Select the corresponding target in the ExpressLRS Configurator, set your Firmware Options and then click Build and Flash. For first time flashing/updating, it would normally take a while. </p> <p>A <code>Success</code> message will be shown once the process is complete.</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-betafpv900/#flashing-via-wifi","text":"<p>Target: <code>BETAFPV_900_RX_via_WIFI</code></p> <p>With the receiver wired properly to your FC, select the correct target and set the Firmware Options in the ExpressLRS Configurator.</p> <p>Build the firmware. Once done, it should open a new window where the <code>BETAFPV_900_RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>BETAFPV_900_RX-&lt;version&gt;.bin</code> is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on the Update button and the firmware file will be uploaded and the update process should commence.</p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Flashing via WiFi"},{"location":"quick-start/rx-betafpv900/#flashing-via-ftdi","text":"<p>Target: <code>BETAFPV_900_RX_via_UART</code></p> <p>Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"Flashing via FTDI"},{"location":"quick-start/rx-bootloader/","text":"<p></p>","title":"Flashing Bootloader"},{"location":"quick-start/rx-bootloader/#r9mmmini-r9mx-r9slim","text":"<p>This guide applies for the R9mm, R9mini, R9mx, R9Slim+, R9Slim+ OTA, if you have a <code>OpenTX</code> transmitter with a <code>SmartPort</code> output, you can flash your RXes bootloader.</p> <p>Download the bootloader <code>.frk</code> file for your respective receiver. The files are as follows:</p> <ul> <li>R9mm/mini: <code>r9mm_elrs_bl.frk</code> (14kb) or <code>r9mm_no_btn_elrs_bl.frk</code> (14kb) (no_btn bootloader is only used if your bind/boot button on the receiver is faulty or has gone bad, and is indicated by both LEDs (red and green) being constantly illuminated.)</li> <li>R9mx: <code>r9mx_elrs_bl.frk</code> (20kb)</li> <li>R9Slim+ (ACCST): <code>r9slim_plus_elrs_bl.frk</code> (14kb)</li> <li>R9Slim+ (ACCESS/OTA): <code>r9slim_plus_ota_elrs_bl.frk</code> (18kb)</li> </ul> <p>Copy the relevant file to your handset's SD card (You can put it inside <code>/FIRMWARE</code> folder for easy access).</p> <p>Wire the receiver to your radio's Smart Port, as shown:</p> <p></p> <p></p> <p>Next, flash the <code>.frk</code> via the <code>S.port</code> flashing option in <code>OpenTX</code>.  (It helps if the External RF module is set to <code>PPM</code> mode.) </p> <ul> <li>Navigate in OpenTX to the TOOLS menu (hold SYS button)</li> <li>Page to the SD-HC CARD page, then the <code>FIRMWARE</code> folder</li> <li>Flash the frk file by holding OK and selecting \"Flash external module\"</li> </ul> <p>Unplug the receiver, and your bootloader is flashed.</p>","title":"R9mm/mini, R9mx, R9Slim+"},{"location":"quick-start/rx-bootloader/#troubleshooting-no-sync","text":"<ul> <li>Setting the External RF module to <code>PPM</code> mode helps.</li> <li>Check if the receiver has its LED lit up or if it's powered.</li> <li>Check whether you've set your <code>Max Bauds</code> to <code>115200</code>, especially if you're using a QX7 or an X9D (on OneBit Firmwares or EdgeTX). If so, put it back to 400k and try again.</li> </ul> <p>You can now proceed to the next step!</p>","title":"Troubleshooting No Sync"},{"location":"quick-start/rx-diyreceivers/","text":"<p></p> <p>Valid Targets:</p> <ul> <li><code>DIY_2400_RX_ESP8285_SX1280_via_BetaflightPassthrough</code></li> <li><code>DIY_2400_RX_ESP8285_SX1280_via_UART</code></li> <li><code>DIY_2400_RX_ESP8285_SX1280_via_WIFI</code></li> <li><code>DIY_2400_RX_STM32_CCG_Nano_v0_5_via_BetaflightPassthrough</code></li> <li><code>DIY_2400_RX_STM32_CCG_Nano_v0_5_via_STLINK</code></li> </ul>","title":"Flashing DIY 2400RX"},{"location":"quick-start/rx-diyreceivers900/","text":"<p></p> <p>Valid Targets:</p> <ul> <li><code>DIY_900_RX_ESP8285_SX127x_via_BetaflightPassthrough</code></li> <li><code>DIY_900_RX_ESP8285_SX127x_via_UART</code></li> </ul>","title":"Flashing DIY 900RX"},{"location":"quick-start/rx-fcprep/","text":"<p></p>","title":"Preparing for Passthrough Flashing"},{"location":"quick-start/rx-fcprep/#wiring-your-receiver","text":"","title":"Wiring your Receiver"},{"location":"quick-start/rx-fcprep/#r9mmmini-r9mx-r9slim","text":"<p> Note: This will be the same wiring you'll use for flying and the subsequent firmware updates (via Passthrough). Forget the factory wiring guide!</p> <p>After you've flashed the bootloader and wired your receiver as above, proceed to configure up your flight controller as shown below.</p> <p>Note: R9 Slim requires flashing via STLink first. Passthrough should work for updates.</p>","title":"R9MM/mini, R9mx, R9Slim+"},{"location":"quick-start/rx-fcprep/#happymodel-ep1-ep2-pp","text":"<p></p> <p>Labels show the receiver pinouts and not to which pads to connect them (in case of the RX and Tx pads). As we're dealing with UART connection, Rx on receiver goes to a TX pad in the FC, and Tx on Receiver goes to an uninverted Rx pad on the FC.</p> <p>There are certain FCs that puts their Receiver UART's RX pads Low, which in turn, puts the EP-based (e.g. EP1 and EP2) receivers to Bootloader mode unintentionally. One remedy is to wire them into a different UART, or wire a pull-up resistor (300-1k ohm) into the RX pad (FC Rx pad -&gt; Resistor -&gt; 3v3 pad).</p> <p>Also of note is that the EP receivers require their Boot pads (see figure above) be bridged on first time Passthrough Flash from their factory firmwares. After the first passthrough flashing, the bridge needs to be removed, and is no longer needed for subsequent passthrough flashing.</p> <p>Flashing via Wifi doesn't need the Boot Pads bridged. Moreover, if it is bridged, the receiver will stay in bootloader mode and won't activate the wifi hotspot.</p> <p>Connect your FC to USB and configure your FC firmware as below.</p>","title":"Happymodel EP1, EP2, PP"},{"location":"quick-start/rx-fcprep/#happymodel-es900rx","text":"<p></p> <p>Shown above is the pinouts for the ES900RX receivers. Connect Rx to a Tx pad on the FC and Tx to an Rx pad on the FC. Additionally, the Boot Pads, encircled in the photo above, needs to be bridged in the first-time passthrough flash from the factory firmware.</p> <p>As this is an ESP-based receiver, be aware that there are certain FCs that puts their Receiver UART's RX pads Low, which in turn, puts the receiver to Bootloader mode unintentionally. One remedy is to wire them into a different UART, or wire a pull-up resistor (300-1k ohm) into the RX pad (FC Rx pad -&gt; Resistor -&gt; 3v3 pad).</p> <p>Should you be updating via Wifi, the bridging of the boot pads is not needed. </p> <p>Connect your FC to USB and configure your FC firmware as shown below.</p>","title":"Happymodel ES900RX"},{"location":"quick-start/rx-fcprep/#happymodel-es915868rx-discontinued","text":"<p></p> <p>Labels in the receiver show the pinouts. Connect Rx to a Tx pad in the FC and the Tx to an Rx pad in the FC. Of course, don't forget to connect VCC to a 5V pad, and GND to a GND pad on the FC.</p> <p>Connect your FC to USB and configure your FC firmware as shown below.</p>","title":"Happymodel ES915/868RX (Discontinued)"},{"location":"quick-start/rx-fcprep/#namimnorc-voyager-flash","text":"<p>Namimno Voyager ExpressLRS Receiver</p> <p></p> <p>Namimno Flash ExpressLRS Receiver</p> <p></p> <p>Labels in the receiver show the pinouts. Connect Rx to a Tx pad in the FC and the Tx to an Rx pad in the FC. Of course, don't forget to connect VCC to a 5V pad, and GND to a GND pad on the FC.</p> <p>Connect your FC to USB and configure your FC firmware as shown below.</p>","title":"NamimnoRC Voyager &amp; Flash"},{"location":"quick-start/rx-fcprep/#betafpv-receivers","text":"<p>BetaFPV 900MHz ExpressLRS Receiver</p> <p></p> <p>BetaFPV 2.4GHz ExpressLRS Receiver</p> <p></p> <p>Shown above are the pinouts and various components of the receivers. Connect Rx to a Tx pad on the FC and Tx to an Rx pad on the FC. Don't forget to also wire up 5v(VCC) and Gnd.</p> <p>Updating via WiFi is supported by these receivers.</p> <p>Connect your FC to USB and configure your FC firmware as shown below.</p>","title":"BetaFPV Receivers"},{"location":"quick-start/rx-fcprep/#mateksys-r24-d-and-r24-s","text":"<p>R24-D</p> <p></p> <p>R24-S</p> <p></p> <p>Shown above are the pinouts and dimensions of the receivers. Connect Rx/R to a Tx pad on the FC and Tx/T to an Rx pad on the FC. Don't forget to also wire up 5v and Gnd.</p> <p>Updating via WiFi is supported by these receivers.</p> <p>Connect your FC to USB and configure your FC firmware as shown below.</p>","title":"MatekSys R24-D and R24-S"},{"location":"quick-start/rx-fcprep/#serial-rx-setup","text":"<p>Once wired up to our Flight Controller, we need to setup the UART for Serial RX. In the example below, the Receiver is wired to a Tx1/Rx1 (UART1) Pad, and so the Serial RX column should be activated on UART1.</p> <p></p>","title":"Serial RX Setup"},{"location":"quick-start/rx-fcprep/#protocol","text":"<p>Similar to your OpenTX Radio, we are using the CRSF protocol between the receiver and the FC firmware (Betaflight/iNav/emuflight), so on the \"Configuration\" tab, you need to select \"Serial-based receiver\" on the \"Receiver\" panel, and select \"CRSF\" as the protocol. Telemetry is optional here and will reduce your stick update rate due to those transmit slots being used for telemetry.</p> <p></p>","title":"Protocol"},{"location":"quick-start/rx-fcprep/#inversion-software-hardware-and-duplex-modes","text":"<p>The CRSF Protocol requires a full UART pair, uninverted and in full-duplex mode. Using the CLI, check if <code>serialrx_inverted</code> is OFF and <code>serialrx_halfduplex</code> is OFF. To do this, simply type <code>get serialrx</code> in the CLI to see the settings for both at the same time. You can use <code>set serialrx_inverted=off</code> or <code>set serialrx_halfduplex=off</code> to turn them off respectively. Don't forget to also type in <code>save</code> after the change.</p> <p>You can't use an RX pad that is shared to an SBUS pad, unless you remove the inversion or reroute the line (by bridging pads in the FC although not all FC have this). The easiest way to determine which UART can be used with ExpressLRS is to check which UART the manufacturer suggests you wire a Crossfire/Ghost receiver to.</p> <p>Use the Navigation Menu to proceed to the Flashing Guides for these Receivers (under the section <code>Flashing Receivers</code>).</p>","title":"Inversion (Software &amp; Hardware) and Duplex Modes"},{"location":"quick-start/rx-flash2400/","text":"<p></p>","title":"Flashing NamimnoRC Flash"},{"location":"quick-start/rx-flash2400/#check-your-target","text":"<p>Because of the massive shortage of <code>STM32</code> Chips, there are more <code>ESP8285</code> based RXes on the market. These support WiFi updating, and can be easily distinguished with a few tricks. The simplest way to tell is if on the rear of the RX (the side without the U.fl/SMD antenna) there is a large white component with the label RainSun (pictured below). If this is not there, you have an STM32 based target, if it is you have an <code>_ESP_</code> target, and can update using Wifi!</p> <p></p>","title":"Check your Target"},{"location":"quick-start/rx-flash2400/#betaflight-passthrough","text":"<p>Targets: </p> <ul> <li><code>NamimnoRC_FLASH_2400_ESP_RX_via_BetaflightPassthrough</code> </li> <li><code>NamimnoRC_FLASH_2400_RX_via_BetaflightPassthrough</code></li> </ul> <p>Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button.</p> <p>If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Firmware Options set, click on Build &amp; Flash. Like on the TX module, it will take a while on the first time. Watch out for the <code>Passthrough Init</code> stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.)</p> <p>Once <code>Retry...</code> lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start.</p> <p>Wait for this process to finish. It's done once the \"Success\" prompt is shown.</p>","title":"Betaflight Passthrough"},{"location":"quick-start/rx-flash2400/#wifi-updating-esp-only-recommended","text":"<p>Target: <code>NamimnoRC_FLASH_2400_ESP_RX_via_WIFI</code></p> <p>With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator.</p> <p>Build the firmware. Once done, it should open a new window where the <code>NamimnoRC_FLASH_2400_ESP_RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>NamimnoRC_FLASH_2400_ESP_RX-&lt;version&gt;.bin</code> is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on the Update button and the firmware file will be uploaded and the update process should commence.</p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Wifi Updating (ESP Only - Recommended)"},{"location":"quick-start/rx-flash2400/#uart-updating-esp-only","text":"<p>Target: <code>NamimnoRC_FLASH_2400_ESP_RX_via_UART</code></p> <p>Wire the receiver into the FTDI, with the TX on receiver connected to the Rx on the FTDI, and the RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"UART Updating (ESP Only)"},{"location":"quick-start/rx-flash2400/#stlink-updating-stm32-only","text":"<p>Target: <code>NamimnoRC_FLASH_2400_RX_via_STLINK</code></p> <p>The units provided to the documentation team did not have STM32 chips due to the chip shortage, however, the following should apply. Wire CLK, 3v3, GND and DIO to the recievers STLink pins.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"STLink Updating (STM32 Only)"},{"location":"quick-start/rx-ghost2400/","text":"<p></p>","title":"Flashing Ghost Receiver"},{"location":"quick-start/rx-ghost2400/#flashing-ghost-attozepto-rxs","text":"<p>Target: <code>GHOST_ATTO_2400_RX_via_STLINK</code></p> <p>Flashing the Ghost RX's is currently a 1 WAY flash once you flash ExpressLRS to these RX's you will not be able to use them with Ghost TX.  You will need a <code>StLink V2</code> to flash the RX's</p> <p></p> <ol> <li>Wire <code>3.3v</code>, <code>GND</code>, <code>CLK</code>, and <code>DIO</code> to their respective pins on the RX from the StLink.</li> <li>Select the <code>GHOST_ATTO_2400_via_STLINK</code> target.</li> <li>Set your Firmware Options and click on <code>Build and Flash</code>.</li> <li>Connect your receiver to your Flight Controller as normal (i.e. Rx to Tx, and Tx to Rx);</li> </ol> <p>Subsequent Firmware Updates can now be done using <code>via_BetaflightPassthrough</code> target.</p>","title":"Flashing Ghost Atto/Zepto RX's"},{"location":"quick-start/rx-hmep2400/","text":"<p></p>","title":"Flashing Happymodel EPs"},{"location":"quick-start/rx-hmep2400/#flashing-via-wifi","text":"<p>(Recommended as first-flash method)</p> <p>Target: <code>HappyModel_EP_2400_RX_via_WIFI</code></p> <p>Wire up your receiver to a free UART on your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC).</p> <p>Note: There are Flight Controllers that will pull the RX pads <code>LOW</code> which will put the ESP-based receivers into <code>Bootloader Mode</code> unintentionally. A solid LED light on these receivers even with the TX module off is a sign they are in Bootloader Mode. If this is the case, rewire the receiver to a different UART.</p> <p>Build the firmware using the ExpressLRS Configurator using the correct Target and options. Once done, it should open a new window where the <code>HappyModel_EP_2400_RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if receiver gets powered from USB via a 4v5 pad). Receiver's LED will blink slow at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same <code>expresslrs</code> password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>HappyModel_EP_2400_RX-&lt;version&gt;.bin</code> is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on Update button and the firmware file will be uploaded and the update process should commence. </p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Flashing via Wifi"},{"location":"quick-start/rx-hmep2400/#flashing-via-passthrough","text":"<p>Target: <code>HappyModel_EP_2400_RX_via_BetaflightPassthrough</code></p> <p>Wire up your receiver to a free uart in your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC).</p> <p>You will need to bridge the <code>Boot</code> pads on the receiver the first time you'll be updating via this method. The wiring guide shows where the <code>Boot</code> pads are. A solid LED indicates the receiver is in <code>Bootloader</code> mode when the TX module is OFF (Solid LED also indicates Radio+module &amp; Receiver is bound and has connection). </p> <p>Note: if you haven't bridged the <code>Boot</code> pads but the receiver has solid LED light, your FC is probably pulling the current UART's RX pad <code>LOW</code> which will interfere with the normal and passthrough flashing of this receiver. Find another UART and wire your receiver there instead</p> <p>Bridging the <code>Boot</code> pads is no longer needed past 1.0.0-RC6. </p> <p>Power your FC with a LiPo, or if receiver is powered via USB (receiver is connected to a 4v5 pad), connect the FC to your USB port. Using the ExpressLRS Configurator, with the correct Target selected and Firmware Options set, click on Build &amp; Flash. Wait for the process to finish and you should be greeted with the \"Success\" banner.</p> <p>Unplug USB and LiPo, and removed the solder on the bridged <code>Boot</code> pads. You no longer need it (past 1.0.0-RC6). Power your TX Module and then your FC to verify you are bound and has connection.</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmep2400/#flashing-via-ftdi","text":"<p>Target: <code>HappyModel_EP_2400_RX_via_UART</code></p> <p>Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Short the boot pad while powering the RX on, and release - the LED should now be solid.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"Flashing via FTDI"},{"location":"quick-start/rx-hmes900/","text":"<p></p>","title":"Flashing Happymodel ES900RX"},{"location":"quick-start/rx-hmes900/#es900rx","text":"","title":"ES900RX"},{"location":"quick-start/rx-hmes900/#flashing-via-passthrough","text":"<p>Target: <code>HappyModel_RX_ES900RX_via_BetaflightPassthrough</code></p> <p></p> <p>With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator, then click on Build and Flash. First time Compile naturally takes a while but if you do the prep work properly, you'll be greeted with the <code>Success</code> message soon enough!</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmes900/#flashing-via-wifi","text":"<p>With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator.</p> <p>Build the firmware. Once done, it should open a new window where the <code>HappyModel_RX_ES900RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>HappyModel_RX_ES900RX-&lt;version&gt;.bin</code> is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on the Update button and the firmware file will be uploaded and the update process should commence.</p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Flashing via Wifi"},{"location":"quick-start/rx-hmes900/#es915868rx-discontinued","text":"","title":"ES915/868RX (Discontinued)"},{"location":"quick-start/rx-hmes900/#flashing-via-passthrough_1","text":"<p>Target: <code>HappyModel_RX_ES915RX_via_BetaflightPassthrough</code></p> <p></p> <p>Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button.</p> <p>If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Firmware Options set, click on Build &amp; Flash. Like on the TX module, it will take a while on the first time. Watch out for the <code>Passthrough Init</code> stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.)</p> <p>Once <code>Retry...</code> lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start.</p> <p>Wait for this process to finish. It's done once the \"Success\" prompt is shown.</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmes900/#flashing-via-stlink","text":"<p>Target: <code>HappyModel_RX_ES915RX_via_STLINK</code></p> <p>Wire up your receiver to your STLink, shown here.</p> <p>Using the correct target specific for your receiver, set your Firmware Options and hit Build &amp; Flash on the ExpressLRS Configurator.</p> <p>Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver.</p>","title":"Flashing via STLink"},{"location":"quick-start/rx-hmpp2400/","text":"<p></p>","title":"Flashing Happymodel PP"},{"location":"quick-start/rx-hmpp2400/#flashing-via-passthrough","text":"<p>Target: <code>HappyModel_PP_2400_RX_via_BetaflightPassthrough</code></p> <p>The PP receivers do not have Wifi, and so, it can only be updated via Passthrough or STLink(see below).</p> <p>Follow the same wiring as that of the EP receivers shown here. The PP has a silkscreened \"RT5G\" on one of its side indicating the order of the pads, with R = Rx, T = Tx, 5 = 5v and G = Gnd,  respectively. Connect the Rx pad to a Tx pad on the FC, and the Tx pad to an RX pad on the FC, with 5v and Gnd to their usual connections.</p> <p>The PP doesn't have a <code>Boot</code> pad either so there's no need to bridge any pads.</p> <p>Once wired, power up your FC by connecting a LiPo or, if the receiver is getting powered via USB, connect your USB cable to a vacant port.</p> <p>Using the ExpressLRS Configurator, with the correct Target selected and Firmware Options set, hit Build &amp; Flash. Wait a bit for the process to finish and you should see a \"Success\" banner. </p> <p>Power-cycle the FC and verify receiver connects to the Tx module (power up the Tx first, then the Receiver).</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmpp2400/#flashing-via-stlink","text":"<p>Target: <code>HappyModel_PP_2400_RX_via_STLINK</code></p> <p></p> <p>This will require connecting a ST Link to CLK, DIO, 5V and GND.</p> <p>Then with the correct Target selected and Firmware Options set, click Build &amp; Flash in the ExpressLRS Configurator. Wait for the process to finish and you should see the \"Success\" banner.</p> <p>Connect your receiver to your FC and you should be ready for the next steps.</p>","title":"Flashing via STLink"},{"location":"quick-start/rx-jumper900/","text":"<p></p> <p>Targets: </p> <ul> <li><code>Jumper_RX_R900MINI_via_STLINK</code></li> <li><code>Jumper_RX_R900MINI_via_BetaflightPassthrough</code></li> </ul> <p>Disable 'Readout Protection'. To do this download the ST-LINK Utility and follow this quick how to video. Or alternatively under linux you can use OpenOCD.</p> <p>Using the correct target specific for your receiver, and your Firmware Options set, click Build &amp; Flash on the ExpressLRS Configurator.</p> <p></p> <p>After the flash is successful, desolder the STLink and connect RX2 and TX2 (you will need to solder on the STM32 pins, see picture) to a flight controller and setting up the receiver with the CRSF serial protocol, the <code>Jumper_RX_R900MINI_via_BetaflightPassthrough</code> target may now be used for future firmware.</p>","title":"Flashing Jumper R9 Mini"},{"location":"quick-start/rx-matek2400/","text":"<p></p>","title":"Flashing Matek R24"},{"location":"quick-start/rx-matek2400/#flashing-via-wifi","text":"<p>Target: <code>MATEK_2400_RX_via_WIFI</code></p> <p>Wire up your receiver to a free UART on your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC).</p> <p>Note: There are Flight Controllers that will pull the RX pads <code>LOW</code> which will put the ESP-based receivers into <code>Bootloader Mode</code> unintentionally. A solid LED light on these receivers even with the TX module off is a sign they are in Bootloader Mode. If this is the case, rewire the receiver to a different UART.</p> <p>Build the firmware using the ExpressLRS Configurator using the correct Target and options. Once done, it should open a new window where the <code>MATEK_2400_RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if receiver gets powered from USB via a 4v5 pad). Receiver's LED will blink slow at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same <code>expresslrs</code> password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>MATEK_2400_RX-&lt;version&gt;.bin</code> is (you can drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on Update button and the firmware file will be uploaded and the update process should commence. </p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Flashing via Wifi"},{"location":"quick-start/rx-matek2400/#flashing-via-passthrough","text":"<p>Target: <code>MATEK_2400_RX_via_BetaflightPassthrough</code></p> <p>Wire up your receiver to a free uart in your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC).</p> <p>Power your FC with a LiPo, or if receiver is powered via USB (receiver is connected to a 4v5 pad), connect the FC to your USB port.</p> <p>Note: if the receiver has solid LED light but is not bound to your module, your FC is probably pulling the current UART's RX pad <code>LOW</code> which will interfere with the normal and passthrough flashing of this receiver. Find another UART and wire your receiver there instead.</p> <p>Using the ExpressLRS Configurator, with the correct Target selected and Firmware Options set, click on Build &amp; Flash. Wait for the process to finish and you should be greeted with the \"Success\" banner.</p> <p>Unplug USB and/or LiPo. Power your TX Module and then your FC to verify you are bound and has connection.</p>","title":"Flashing via Passthrough"},{"location":"quick-start/rx-matek2400/#flashing-via-uart","text":"<p>Target: <code>MATEK_2400_RX_via_UART</code></p> <p>Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"Flashing via UART"},{"location":"quick-start/rx-r9receivers/","text":"<p></p>","title":"Flashing Frsky R9 Receivers"},{"location":"quick-start/rx-r9receivers/#frsky-rxes","text":"<p> Note: This will be the same wiring you'll use for flying and the next firmware updates (via Passthrough). Forget the factory wiring guide!</p>","title":"FrSky RXes"},{"location":"quick-start/rx-r9receivers/#passthrough-flashing-works-with-betaflight-inav","text":"<p>Valid Targets:</p> <ul> <li><code>Frsky_RX_R9MM_R9MINI_via_BetaflightPassthrough</code></li> <li><code>Frsky_RX_R9MX_via_BetaflightPassthrough</code></li> <li><code>Frsky_RX_R9SLIM_via_BetaflightPassthrough</code></li> <li><code>Frsky_RX_R9SLIMPLUS_via_BetaflightPassthrough</code></li> <li><code>Frsky_RX_R9SLIMPLUS_OTA_via_BetaflightPassthrough</code></li> </ul> <p>Make sure the correct Bootloader has been flashed to the receiver prior to wiring it up to your flight controller. Using the wiring guide above, find a free, uninverted UART in your FC. You can use your FC's wiring guide for a Crossfire or Ghost receiver.</p> <p>Once wired to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button.</p> <p>If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Firmware Options set, click on Build &amp; Flash. Like on the TX module, it will take a while on the first time. Watch out for the <code>Passthrough Init</code> stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.)</p> <p>Once <code>Retry...</code> lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your FC and receiver). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start prior to connecting the USB.</p> <p>Wait for this process to finish. It's done once the \"Success\" prompt is shown.</p>","title":"Passthrough Flashing (works with Betaflight, iNav)"},{"location":"quick-start/rx-r9receivers/#flashing-via-stlink-only-recommended-as-last-resort","text":"<p>Valid Targets:</p> <ul> <li><code>Frsky_RX_R9MM_R9MINI_via_STLINK</code></li> <li><code>Frsky_RX_R9MX_via_STLINK</code></li> <li><code>Frsky_RX_R9SLIM_via_STLINK</code></li> <li><code>Frsky_RX_R9SLIMPLUS_via_STLINK</code></li> <li><code>Frsky_RX_R9SLIMPLUS_OTA_via_STLINK</code></li> </ul> <p>This method is irreversible. It will remove the ability to reflash back to Frsky firmware. You have been warned! Make sure your STLink dongle is properly recognized by your System as such (Drivers are installed, etc.).</p> <p>Disable 'Readout Protection'. To do this download the ST-LINK Utility and follow this quick how to video. Or alternatively under linux you can use OpenOCD. </p> <p>After doing so, Disconnect from STLink Utility.</p> <p>Using the correct target specific for your receiver, set your Firmware Options and hit Build &amp; Flash on the ExpressLRS Configurator.</p> <p>Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver.</p>","title":"Flashing via STLink (only recommended as last resort)"},{"location":"quick-start/rx-siyiFRmini/","text":"<p></p> <p>Targets:</p> <ul> <li><code>FM30_RX_MINI_via_STLINK</code> (First-time Flash)</li> <li><code>FM30_RX_MINI_via_BetaflightPassthrough</code> (Updates)</li> </ul> <p>Note: only guaranteed to work on the v3.0 of the receiver.</p> <p>The STLink solderpads on the FRmini RX are very tiny and very close together. The picture below is very enlarged. Solder 5  (preferable Silicon) wires to the GND-RST-VDD-CLK-DIO pads. Solder the open ends to a female 2.54 mm pin connector. (Use 3.3V NOT 5V ).</p> <p> </p> <p>Using the correct target specific for your receiver, set your Firmware Options and hit Build &amp; Flash on the ExpressLRS Configurator.</p> <p>Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver. The wiring is show below, where the FC TX goes to RX2 and the FC RX goes to TX2.</p> <p> </p> <p>Thank you to @JupaCreations</p>","title":"Flashing Siyi FR Mini"},{"location":"quick-start/rx-stlink/","text":"<p></p> <p>Disable readout protection as shown in this video:</p>","title":"Preparing for STLink Flashing"},{"location":"quick-start/rx-stlink/#r9mmmini","text":"<p>Connect the STLink V2 into the pads shown below: <code>3v3</code>, <code>GND</code>, <code>C = CLK</code> and <code>D = DIO</code>. </p> <p></p>","title":"R9MM/Mini"},{"location":"quick-start/rx-stlink/#r9mx","text":"<p>Connect the STLink V2 into the pads shown below: <code>3v3</code>, <code>GND</code>, <code>C = CLK</code> and <code>D = DIO</code>. </p> <p></p>","title":"R9MX"},{"location":"quick-start/rx-stlink/#r9slim","text":"<p>This RX requires an StLink v2 to be flashed. </p> <p>Wire up the RX to the STLink using <code>3v3</code>, <code>GND</code>, <code>CLK</code> and <code>DIO</code>. </p> <p></p> <p>Wiring the R9 Slim+ for STLink flashing will be the same</p>","title":"R9Slim"},{"location":"quick-start/rx-stlink/#jumper-r900-mini","text":"<p>This also requires an STLink, so the wiring is as follows:  Wire <code>+ = 3v3</code>, <code>- = GND</code>, <code>C = CLK</code> and <code>D = DIO</code> to their respective pins on the RX from the StLink. </p> <p>Because those pins are so small one option is to only solder a wire on the <code>CLK</code> and <code>DIO</code> then power it with the 5v pin with an external power source. </p>","title":"Jumper R900 Mini"},{"location":"quick-start/rx-stlink/#es915rx-discontinued","text":"<p></p> <p>Connect your STLink into <code>GND</code>, <code>DIO</code>, <code>CLK</code>, <code>3V3</code> of the receiver. These pads are marked clearly as in the image above.</p> <p>Use the Navigation Menu to proceed to the Flashing Guides for these Receivers (under the section <code>Flashing Receivers</code>).</p>","title":"ES915RX (Discontinued)"},{"location":"quick-start/rx-voyager900/","text":"<p></p>","title":"Flashing NamimnoRC Voyager"},{"location":"quick-start/rx-voyager900/#check-your-target","text":"<p>Because of the massive shortage of <code>STM32</code> Chips, there are more <code>ESP8285</code> based RXes on the market. These support WiFi updating, and can be easily distinguished with a few tricks. The simplest way to tell is if on the rear of the RX (the side without the U.fl/SMD antenna) there is a large white component with the label RainSun (pictured below). If this is not there, you have an STM32 based target, if it is you have an <code>_ESP_</code> target, and can update using Wifi!</p> <p></p>","title":"Check your Target"},{"location":"quick-start/rx-voyager900/#betaflight-passthrough","text":"<p>Targets: </p> <ul> <li><code>NamimnoRC_VOYAGER_900_ESP_RX_via_BetaflightPassthrough</code> </li> <li><code>NamimnoRC_VOYAGER_900_RX_via_BetaflightPassthrough</code></li> </ul> <p>Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button.</p> <p>If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Firmware Options set, click on Build &amp; Flash. Like on the TX module, it will take a while on the first time. Watch out for the <code>Passthrough Init</code> stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.)</p> <p>Once <code>Retry...</code> lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start.</p> <p>Wait for this process to finish. It's done once the \"Success\" prompt is shown.</p>","title":"Betaflight Passthrough"},{"location":"quick-start/rx-voyager900/#wifi-updating-esp-only-recommended","text":"<p>Target: <code>NamimnoRC_VOYAGER_900_ESP_RX_via_WIFI</code></p> <p>With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator.</p> <p>Build the firmware. Once done, it should open a new window where the <code>NamimnoRC_VOYAGER_900_ESP_RX-&lt;version&gt;.bin</code> is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver.</p> <p>Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using <code>AUTO_WIFI_ON_INTERVAL</code>), it should blink fast indicating it's on Wifi Hotspot Mode.</p> <p>Connect to the Wifi Network the receiver has created. It should be named something like <code>ExpressLRS RX</code> with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver <code>NamimnoRC_VOYAGER_900_ESP_RX-&lt;version&gt;.bin</code> is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the <code>Browse</code> or <code>Choose File</code> button). Click on the Update button and the firmware file will be uploaded and the update process should commence.</p> <p>A white page should load momentarily with the message Update Success! Rebooting.... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).</p>","title":"Wifi Updating (ESP Only - Recommended)"},{"location":"quick-start/rx-voyager900/#uart-updating-esp-only","text":"<p>Target: <code>NamimnoRC_VOYAGER_900_ESP_RX_via_UART</code></p> <p>Wire the receiver into the FTDI, with the TX on receiver connected to the Rx on the FTDI, and the RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"UART Updating (ESP Only)"},{"location":"quick-start/rx-voyager900/#stlink-updating-stm32-only","text":"<p>Target: <code>NamimnoRC_VOYAGER_900_RX_via_STLINK</code></p> <p>The units provided to the documentation team did not have STM32 chips due to the chip shortage, however, the following should apply. Wire CLK, 3v3, GND and DIO to the recievers STLink pins.</p> <p>Select the target and set your Firmware Options and once done, click on Build and Flash.</p>","title":"STLink Updating (STM32 Only)"},{"location":"quick-start/troubleshooting/","text":"<p></p>","title":"Troubleshooting"},{"location":"quick-start/troubleshooting/#general-troubleshooting","text":"","title":"General Troubleshooting"},{"location":"quick-start/troubleshooting/#my-rx-and-tx-are-bound-but-fc-is-not-responding-to-inputs-and-i-can-only-see-10-telemetry-sensors","text":"<p>Check whether you have wired the receiver correctly and that Rx and Tx wires aren't swapped.</p> <p>Also check that you have the correct SerialRX configuration. You might want to revisit the FC Preparation page for the Flight Controller setup.</p> <p>Also make sure that the UART where you connected the receiver doesn't have inversion and it's in full duplex mode. You can also try a different UART.</p>","title":"My RX and TX are bound, but FC is not responding to inputs, and I can only see 10 Telemetry sensors"},{"location":"quick-start/troubleshooting/#my-rx-and-tx-are-bound-and-im-getting-stick-inputs-but-i-can-only-get-10-telemetry-sensors","text":"<p>Check if you have Telemetry Feature enabled in your FC Configuration.</p> <p>Also verify the Rx pad from receiver is connected properly to a Tx pad in the FC in the same UART as the Tx wire from receiver.</p> <p>Also make sure you have deleted and rediscovered the sensors. It's good to increase the TLM Ratio so the acquisition of the sensors will be faster.</p>","title":"My RX and TX are bound, and I'm getting stick inputs, but I can only get 10 Telemetry sensors"},{"location":"quick-start/troubleshooting/#i-think-my-rx-and-tx-are-bound-as-the-led-on-the-receiver-is-solid-but-i-dont-have-stick-inputs-or-rssi-on-radio","text":"<p>You are not bound. Your Receiver is probably in bootloader mode.</p> <p>Make sure you have unbridged the boot pads if you did flashed it via passthrough.</p> <p>Turn off your Radio and if the LED is still solid, but boot pads aren't bridged, the UART where the receiver is on is putting it into bootloader mode unintentionally. Best to move it to another UART. To verify it is the case with the UART, disconnect the Rx and Tx wires from the UART, and it should start blinking slow.</p> <p>If, however, despite unsoldering the Tx and Rx wires, the LED is still solid, you probably have a soft-bricked receiver due to a failed WiFi flash as a result of not letting the receiver reboot normally. See this section for the fix.</p>","title":"I think my RX and TX are bound as the LED on the Receiver is solid. But I don't have stick inputs or RSSI on radio."},{"location":"quick-start/troubleshooting/#my-osd-is-showing-lq-00-and-rssi-dbm-at-130-dbm-but-i-have-stick-inputs-and-more-than-10-telemetry-sensors","text":"<p>Check whether you have RSSI Channel set to either Aux11 or Aux12. If you do, set it to disabled.</p> <p>If it's still not fixed with that, check if you have RSSI ADC enabled. If so, set it to disabled.</p>","title":"My OSD is showing LQ 0:0 and RSSI dbm at -130 dbm, but I have stick inputs and more than 10 Telemetry sensors"},{"location":"quick-start/troubleshooting/#my-osd-is-showing-lq-31-sometimes-lq-39","text":"<p>Move your LQ OSD element around as it could be being obstructed by another element or it's too far to the right of the preview.</p>","title":"My OSD is showing LQ 3:1 sometimes LQ 3:9"},{"location":"quick-start/troubleshooting/#i-am-getting-telemetry-lostrecovered-and-is-getting-annoying","text":"<p>There's a handful of reasons why this is occuring, and if you have newer handset/radio, it shouldn't happen at all unless you're flying very far away using a receiver without an amplifier on its Telemetry signal (e.g. the EP receivers).</p> <ul> <li>You're on an X9D(+) or a QX7 with subpar inverter chips. Check this page on how to remedy it.</li> <li>You're on an early version of the Happymodel Slim Pro. Check this FB post for the fix from manufacturer.</li> <li>You're using a 2018 ACCST R9M, while also using a Radio with 400k or higher Baud rate. You will either have to lower the Baud rate on your radio to 115200 (QX7) or do the Resistor mod on the module as described here.</li> <li>Your module is getting loose inside its enclosure, most common on the first batches of the Happymodel ES24TX (white 3D-Printed enclosure; although the black one is only marginally better having 4 screw points instead of 2). You either have to print your own enclosure (search Thingiverse for \"expresslrs\") or find a way to tighten or snug the enclosure with the module board.</li> <li>Check the S.Port pin and connection in your module and bay, and make sure they have a solid physical connection. On the DIY modules, particularly the full size module, the round hole/via for the Molex connector's flat pin isn't getting good connection due to cold solder joint, or insufficient solder.</li> </ul>","title":"I am getting Telemetry Lost/Recovered and is getting annoying"},{"location":"quick-start/troubleshooting/#i-need-to-plug-my-fc-a-secondthird-time-before-i-get-a-bind-led-on-receiver-is-dim-when-i-power-it-up","text":"<p>Update to the latest firmware as soon as you can. A batch of HM receivers have reached the market with Voltage regulators (marked SDG) that were insufficient and wasn't able to handle the higher current draw during boot up. To learn more of this issue and the fix, please check out this PR.</p>","title":"I need to plug my FC a second/third time before I get a bind. LED on receiver is dim when I power it up."},{"location":"quick-start/troubleshooting/#betaflight-lua-is-stuck-at-initializing","text":"<p>Increase the TLM Ratio via the ExpressLRS Lua script to values like 1:4 or even 1:2 and retry the Betaflight Lua script.</p> <p>Also, you have to make sure you're getting more than ten (10) Telemetry sensors prior to launching the script.</p> <p>See MSP Section for more info.</p>","title":"Betaflight Lua is stuck at \"Initializing\""},{"location":"quick-start/troubleshooting/#my-blackbox-log-has-stepping-on-the-rc-trace","text":"<p>Make sure you have disabled ADC Filter in your Radio Hardware settings.</p>","title":"My Blackbox Log has stepping on the RC trace"},{"location":"quick-start/troubleshooting/#flashingupdating","text":"<p>Note: Individual hardware Flashing and Updating guide can be found by using the menu on the left sidebar.</p>","title":"Flashing/Updating"},{"location":"quick-start/troubleshooting/#invalid-serial-rx-configuration-detected","text":"<p>This is often caused by incorrect Serial RX protocol (should be CRSF), or serialrx_inverted = on (should be off) or serialrx_halfduplex=on (should be off). The Passthrough Init section of the log will show you which setting should be corrected. See this page for setting up your Flight Controller.</p>","title":"Invalid serial RX configuration detected"},{"location":"quick-start/troubleshooting/#rx-serial-not-found","text":"<p>Make sure your Serial RX on the Ports Tab of your FC Firmware configurator is set to the correct UART.</p>","title":"RX Serial not found !!!!"},{"location":"quick-start/troubleshooting/#no-cli-available","text":"<p>This message can be seen on the ExpressLRS Configurator Log while using the Passthrough method and can be caused by a busy Com Port. Make sure any other Configurator Apps were closed and unplug-replug your FC to USB. You might also want to use a different USB port or cable.</p> <p>This could also mean that the FC cannot be detected by the script. This could also due to the FC being in DFU mode, which for passthrough flashing, is not needed.</p>","title":"No CLI Available"},{"location":"quick-start/troubleshooting/#10-retries-but-no-success","text":"<p>This can be due to several things:</p> <ul> <li>Incorrect bootloader is flashed or it's not flashed properly. This mainly happen on the R9 receivers. Go checkout Bootloader Flashing Guide.</li> <li>Incorrect wiring. Make sure that Rx in the Receiver is connected to a Tx pad in the FC and the Tx in the Receiver is connected to an Rx pad in the FC. Also make sure receiver is getting enough voltage (min 4v5) from the FC or voltage supply. Wiring guide is here</li> <li>Receiver is OFF. Check whether the LED on the receiver is lit, indicating it's powered and in working state.</li> <li>The UART has hardware inversion. Make sure that the UART you've connected the receiver to is not an SBUS UART that's usually have hardware inversion (most common among F4 Flight Controllers). There are Flight controllers that require you bridge a pair of pads to enable or disable the Hardware inversion of an Rx pad. You can simply try a different UART.</li> <li>The LED on the receiver is SOLID, while radio is off, could only mean that the Rx pad in the FC is being pulled LOW, putting the ESP-based receiver (EPs, ES900Rx, etc.) into Bootloader mode unintentionally, which will hinder normal passthrough operations. Feel free to try a different UART.</li> </ul>","title":"10 Retries but no Success"},{"location":"quick-start/troubleshooting/#failed-to-connect-to-esp8266-timed-out-waiting-for-packet-header","text":"<p>This can be due to several things:</p> <ul> <li>Receiver is wired incorrectly. Please check if the Rx and Tx wires isn't swapped and connected Rx to Rx and Tx to Tx on the FC. Revisit the FC preparation page here.</li> <li>The receiver's \"boot\" pads aren't bridged (or the button wasn't pressed and held during power up) for passthrough flashing. This is required for Passthrough flashing if the receiver is fresh from the packet and has a firmware version before 1.0.0-RC6.</li> <li>The receiver uart is putting it in Bootloader mode and is interfering with passthrough flashing. Move it into another UART.</li> </ul> <p>You can also attempt the update the via UART using an FTDI Adapter (or a USB to UART Bridge).</p> <p>Please see the Flashing guide for your particular receiver using the Sidebar on the Left.</p>","title":"Failed to connect to ESP8266: Timed out waiting for packet header."},{"location":"quick-start/troubleshooting/#i-updated-via-wifi-but-now-receiver-wont-work-and-has-solid-led","text":"<p>This is a sign that the Wifi flashing didn't go through properly due to premature power cycle. To fix this, you will have to bridge the boot pads (see here) and reflash using the Passthrough method (Telemetry option on Betaflight/iNav set to <code>OFF</code>. This is important!) or using an FTDI adapter.</p> <p>This video shows the steps albeit using vscode development environment but the ExpressLRS Configurator will work just fine. </p>  <p>To ensure that the WiFi flashing finished properly, wait until the LED on the receiver blinks slow (indicating it's looking for a TX bind) before pulling off power.</p>","title":"I updated via WiFi but now receiver won't work and has SOLID LED"},{"location":"quick-start/tx-betafpv2400/","text":"<p></p>","title":"Flashing BetaFPV Nano 2.4Ghz"},{"location":"quick-start/tx-betafpv2400/#flashing-via-wifi","text":"<p>Target: <code>BETAFPV_2400_TX_via_WIFI</code></p> <p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>BETAFPV_2400_TX-&lt;version&gt;.bin</code> file is. Do not close this window so you can easily locate the correct file to upload to the module.</p> <p>The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's <code>/Scripts/Tools</code> folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua.</p> <p> </p> <p>At first, it will show \"Mismatch\"; it's normal. Tap <code>Enter</code> once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio.</p> <p></p> <p>Select Wifi Update from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as <code>ExpressLRS TX Module</code>, and the password is simply <code>expresslrs</code>.</p> <p>Using your browser, navigate to the correct page (typically http://10.0.0.1/) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the <code>BETAFPV_2400_TX-&lt;version&gt;.bin</code> file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the <code>Browse</code> or <code>Choose File</code> button on the Upload form. Click on <code>Update</code> once and the update process should commence. Take note that you should be taking a TX firmware file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator.</p> <p>Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting...</p> <p>As it rebooted, the connection to the Webserver got terminated. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via Wifi"},{"location":"quick-start/tx-betafpv2400/#flashing-via-usbuart","text":"<p>Target: <code>BETAFPV_2400_TX_via_UART</code></p> <p>Attach a USB Data Cable to your module and Computer. Windows users might have to install CP210x Drivers to ensure the device is properly detected and initialized.</p> <p>Using the ExpressLRS Configurator with the correct Target selected and Firmware Options set, hit Build &amp; Flash. Wait for the process to finish, and you should be greeted with the \"Success\" message.</p> <p>Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via USB/UART"},{"location":"quick-start/tx-betafpv2400/#cant-flash","text":"<p>If you've followed any of the steps above and still can't get your devices flashed and updated, see this video for the explanation why and the fix to get your devices flashed and updated.</p>","title":"Can't flash?"},{"location":"quick-start/tx-betafpv900/","text":"<p></p>","title":"Flashing BetaFPV Nano 900Mhz"},{"location":"quick-start/tx-betafpv900/#flashing-via-wifi","text":"<p>Target: <code>BETAFPV_900_TX_via_WIFI</code></p> <p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>BETAFPV_900_TX-&lt;version&gt;.bin</code> file is. Do not close this window so you can easily locate the correct file to upload to the module.</p> <p>The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's <code>/Scripts/Tools</code> folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua.</p> <p> </p> <p>At first, it will show \"Mismatch\"; it's normal. Tap <code>Enter</code> once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio.</p> <p></p> <p>Select Wifi Update from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as <code>ExpressLRS TX Module</code>, and the password is simply <code>expresslrs</code>.</p> <p>Using your browser, navigate to the correct page (typically http://10.0.0.1/) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the <code>BETAFPV_900_TX-&lt;version&gt;.bin</code> file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the <code>Browse</code> or <code>Choose File</code> button on the Upload form. Click on <code>Update</code> once and the update process should commence. Take note that you should be taking a TX firmware file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator.</p> <p>Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting...</p> <p>As it rebooted, the connection to the Webserver got terminated. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via Wifi"},{"location":"quick-start/tx-betafpv900/#flashing-via-usbuart","text":"<p>Target: <code>BETAFPV_900_TX_via_UART</code></p> <p>Attach a USB Data Cable to your module and Computer. Windows users might have to install CP210x Drivers to ensure the device is properly detected and initialized.</p> <p>Using the ExpressLRS Configurator with the correct Target selected and Firmware Options set, hit Build &amp; Flash. Wait for the process to finish, and you should be greeted with the \"Success\" message.</p> <p>Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via USB/UART"},{"location":"quick-start/tx-betafpv900/#cant-flash","text":"<p>If you've followed any of the steps above and still can't get your devices flashed and updated, see this video for the explanation why and the fix to get your devices flashed and updated.</p>","title":"Can't flash?"},{"location":"quick-start/tx-diy/","text":"<p></p> <p>Valid Targets:</p> <ul> <li><code>DIY_2400_TX_ESP32_SX1280_E28_via_UART</code></li> <li><code>DIY_2400_TX_ESP32_SX1280_LORA1280F27_via_UART</code></li> <li><code>DIY_2400_TX_ESP32_SX1280_Mini_via_UART</code></li> </ul> <p>Plug the ESP32 of the DIY TX into the USB of your computer. Then select the correct target given the RF chip you chose and press Build &amp; Flash. Further updates can be performed by building and flashing the <code>.bin</code> file to the external module using OpenTX.</p>","title":"Flashing DIY 2400TX"},{"location":"quick-start/tx-diy900/","text":"<p></p>","title":"Flashing DIY 900TX"},{"location":"quick-start/tx-diy900/#esp32-targets","text":"<p>Valid Targets: - <code>DIY_900_TX_ESP32_SX127x_E19_via_UART</code> - <code>DIY_900_TX_ESP32_SX127x_RFM95_via_UART</code></p> <p>Plug the ESP32 of the DIY TX into the USB of your computer. Then select the correct target given the RF chip you chose and press Build &amp; Flash. Further updates can be performed by building and flashing the <code>.bin</code> file to the external module using OpenTX.</p>","title":"ESP32 Targets"},{"location":"quick-start/tx-diy900/#ttgo-targets","text":"<p>Valid Targets: - <code>DIY_900_TX_TTGO_V1_SX127x_via_UART</code> - <code>DIY_900_TX_TTGO_V2_SX127x_via_UART</code></p> <p>Plug the TTGo into the USB of your computer. Then select the correct target given the version you have and press Build &amp; Flash. Further updates can be performed by building and flashing the <code>.bin</code> file to the external module using OpenTX.</p>","title":"TTGo Targets"},{"location":"quick-start/tx-es24tx/","text":"<p></p>","title":"Flashing Happymodel ES24TX"},{"location":"quick-start/tx-es24tx/#flashing-via-wifi","text":"<p>Targets:</p> <ul> <li><code>HappyModel_ES24TX_2400_TX_via_WIFI</code></li> <li><code>HappyModel_ES24TX_Slim_Pro_2400_TX_via_WIFI</code></li> </ul> <p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>HappyModel_ES24TX_2400_TX-&lt;version&gt;.bin</code> or <code>HappyModel_ES24TX_Slim_Pro_2400_TX-&lt;version&gt;.bin</code> file is. Do not close this window so you can easily locate the correct file to upload to the module.</p> <p>The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's <code>/Scripts/Tools</code> folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua.</p> <p> </p> <p>At first, it will show \"Mismatch\"; it's normal. Tap <code>Enter</code> once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio.</p> <p></p> <p>Select \"Wifi Update\" from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as <code>ExpressLRS TX Module</code>, and the password is simply <code>expresslrs</code>.</p> <p>Using your browser, navigate to the correct page (typically http://10.0.0.1/) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the <code>HappyModel_ES24TX_2400_TX-&lt;version&gt;.bin</code> or <code>HappyModel_ES24TX_Slim_Pro_2400_TX-&lt;version&gt;.bin</code> file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the <code>Browse</code> or <code>Choose File</code> button on the Upload form. Click on <code>Update</code> once and the update process should commence. Take note that you should be taking a TX firmware file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator.</p> <p>Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting...</p> <p>As it rebooted, the connection to the Webserver got terminated. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via WiFi"},{"location":"quick-start/tx-es24tx/#flashing-via-usbuart","text":"<p>Targets:</p> <ul> <li><code>HappyModel_ES24TX_2400_TX_via_UART</code></li> <li><code>HappyModel_ES24TX_Slim_Pro_2400_TX_via_UART</code></li> </ul> <p>This method requires you move two jumpers into specific pins in the module board. See the following image for the jumper location and which pin should be bridged for this method to work.</p> <p></p> <p></p> <p></p> <p>The jumpers should be moved into the USB/UART (Green) position from the images above. Attach your USB cable into the module and your computer. CP210x Drivers will have to be installed for this to work properly (Windows). Make sure your computer recognizes the module as a USB-to-UART Bridge device, otherwise, this method will not work.</p> <p>Note: The new Slim Pro doesn't have jumpers or dip switches that you need to move in order to flash via USB. Just connect USB and make sure your computer has recognized the device as a USB-to-UART Bridge (i.e. install the needed CP210x drivers).</p> <p>Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build &amp; Flash. Wait for the process to finish, and you should be greeted with the \"Success\" message.</p> <p>Assemble the module back together and attach it to your radio module bay and verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via USB/UART"},{"location":"quick-start/tx-es900tx/","text":"<p></p>","title":"Flashing Happymodel ES900TX"},{"location":"quick-start/tx-es900tx/#es900tx","text":"","title":"ES900TX"},{"location":"quick-start/tx-es900tx/#flashing-via-wifi","text":"<p>Target: <code>HappyModel_TX_ES900TX_via_WIFI</code></p> <p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>HappyModel_TX_ES900TX-&lt;version&gt;.bin</code> file is. Do not close this window so you can easily locate the correct file to upload to the module.</p> <p>The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's <code>/Scripts/Tools</code> folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua.</p> <p> </p> <p>At first, it will show \"Mismatch\"; it's normal. Tap <code>Enter</code> once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio.</p> <p></p> <p>Select \"Wifi Update\" from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as <code>ExpressLRS TX Module</code>, and the password is simply <code>expresslrs</code>.</p> <p>Using your browser, navigate to the correct page (typically http://10.0.0.1/) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the <code>HappyModel_TX_ES900TX-&lt;version&gt;.bin</code> file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the <code>Browse</code> or <code>Choose File</code> button on the Upload form. Click on <code>Update</code> once and the update process should commence. Take note that you should be taking a TX firmware file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator.</p> <p>Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting...</p> <p>As it rebooted, the connection to the Webserver got terminated. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via Wifi"},{"location":"quick-start/tx-es900tx/#flashing-via-usb","text":"<p>Target: <code>HappyModel_TX_ES900TX_via_UART</code></p> <p>This method requires you move two jumpers into specific pins in the module board. See the following image for the jumper location and which pin should be bridged for this method to work.</p> <p></p> <p>The 2 bottom-most dipswitch should be moved into the position as shown in the image above. Attach your USB cable into the module and your computer. CP210x Drivers will have to be installed for this to work properly (Windows). Make sure your computer recognizes the module as a USB-to-UART Bridge device, otherwise, this method will not work.</p> <p>Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build &amp; Flash. Wait for the process to finish, and you should be greeted with the \"Success\" message.</p> <p>Assemble the module back together and attach it to your radio module bay and verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.</p>","title":"Flashing via USB"},{"location":"quick-start/tx-es900tx/#es915868tx-discontinued","text":"","title":"ES915/868TX (Discontinued)"},{"location":"quick-start/tx-es900tx/#flashing-via-opentx","text":"<p>Target: <code>HappyModel_TX_ES915TX_via_stock_BL</code></p> <p>Using Build in the ExpressLRS Configurator, wait for the firmware to be compiled. After that's done, ExpressLRS Configurator Log should show the <code>Success</code> Message, and it will automatically open the folder where the firmware.elrs can be found. Put (copy-paste) the firmware.elrs to your Radio's SD Card (preferably to the <code>/FIRMWARE</code> folder for easy access). Once on your radio, navigate to the <code>/FIRMWARE</code> folder, select the firmware.elrs and click-hold the Enter button and select \"Flash External ELRS\".</p> <p>Wait for the flashing to finish, module will reboot and you should hear the tune and two beeps (if external module is now set to CRSF protocol).</p>","title":"Flashing via OpenTX"},{"location":"quick-start/tx-es900tx/#flashing-via-stlink","text":"<p>Target: <code>HappyModel_TX_ES915TX_via_STLINK</code></p> <p>Connect your STLink v2 to the pads shown on the image below.</p> <p></p> <p>With the module connected shown above, and your configuration set, hit Build &amp; Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. The ExpressLRS tune should play and then two beeps after that can be heard.</p> <p>Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.</p>","title":"Flashing via STLink"},{"location":"quick-start/tx-flash2400/","text":"<p></p>","title":"Flashing NamimnoRC Flash"},{"location":"quick-start/tx-flash2400/#flashing-via-wifi","text":"<p>Target: <code>NamimnoRC_Flash_2400_TX_via_WiFi</code></p>","title":"Flashing via Wifi"},{"location":"quick-start/tx-flash2400/#method-1","text":"<p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>firmware.elrs</code> file is. Do not close this window so you can easily locate the correct file to upload to the module.</p> <p>These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The <code>Wifi Update</code> option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead.</p> <p>Attach the module to your JR Bays and power it up. Connect to the <code>ESP Wifi Manager</code> Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). </p> <p></p> <p>Press <code>Configure WiFi</code> and set your home network SSID and password. This will enable your Tx Module to connect to your local home network.</p> <p>On your browser, refresh the http://elrs_tx.local/ and scroll towards the STM32 Firmware Update section, as shown below:</p> <p></p> <p>Drag-and-drop the <code>firmware.elrs</code> file created by the ExpressLRS Configurator into the Choose File field, or manually navigate to the Folder by clicking the Choose File button. You can also upload the <code>firmware.bin</code> file but change the offset to 0x4000.Once the correct file is selected, click the <code>Upload and Flash STM32</code>. Wait for the process to complete, and the module will reboot (~2-3min). Using the ELRS.lua script, verify that you have the latest version.</p>","title":"Method 1"},{"location":"quick-start/tx-flash2400/#method-2","text":"<p>These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The <code>Wifi Update</code> option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead.</p> <p>Attach the module to your JR Bays and power it up. Connect to the <code>ESP Wifi Manager</code> Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). </p> <p></p> <p>Press <code>Configure WiFi</code> and set your home network SSID and password. This will enable your Tx Module to connect to your local home network.</p> <p>Using the ExpressLRS Configurator, select the correct Target and set your Firmware Options. Click Build and Flash and wait for the compile process to complete. You should see a section as pictured below and the Success message marking the update process complete.</p> <p></p> <p>Using the ELRS.lua script, verify that you have the latest version.</p>","title":"Method 2"},{"location":"quick-start/tx-flash2400/#flashing-via-opentx-radio","text":"<p>Note: The <code>NamimnoRC_Flash_2400_TX_via_WiFi</code> Target will work for this method too!</p> <p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>NamimnoRC_Flash_2400_TX-&lt;version&gt;.elrs</code> file is. Do not close this window so you can easily locate the correct file to copy to your Radio SD Card.</p> <p>Copy the <code>NamimnoRC_Flash_2400_TX-&lt;version&gt;.elrs</code> file into your radio's SD Card <code>/FIRMWARE</code> folder.</p> <p>Once copied, navigate to the <code>/FIRMWARE</code> Folder on your Radio and select/highlight the <code>NamimnoRC_Flash_2400_TX-&lt;version&gt;.elrs</code> file, long-press the Enter key and select <code>Flash external ELRS</code>. Radio should show a <code>Flash Successful</code> message and you're done!</p> <p>Using the ELRS.lua script, verify that you have the latest version.</p>","title":"Flashing via OpenTX Radio"},{"location":"quick-start/tx-flash2400/#flashing-via-stlink","text":"<p>Target: <code>NamimnoRC_Flash_2400_TX_via_STLINK</code></p> <p>ONLY USE THIS METHOD IF THE FIRMWARE HAS BEEN CORRUPTED </p> <p>Begin by disassembling the module by unscrewing the 4 screws at the rear of the module with a 1.5mm hex wrench. Carefully seperate the parts of the module and detach the cable from the main PCB.</p> <p> </p> <p>Wire your <code>STLink v2</code> to the module's pins as show below:</p> <p></p> <p>With the module connected shown above, and your configuration set, hit Build &amp; Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. If the Radio has CRSF selected, the light should turn green meaning the module has communication with your radio.</p> <p>Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.</p>","title":"Flashing via STLink"},{"location":"quick-start/tx-ghost2400/","text":"<p></p>","title":"Flashing Ghost TX"},{"location":"quick-start/tx-ghost2400/#flashing-ghost-modules-via-stlink","text":"<p>Targets:</p> <ul> <li><code>GHOST_2400_TX_via_STLINK</code></li> <li><code>GHOST_2400_TX_LITE_via_STLINK</code></li> </ul>","title":"Flashing Ghost Modules via STLink"},{"location":"quick-start/tx-ghost2400/#initial-flash","text":"<p>Here is a 10 minute video, showing the steps required to both flash the TX if you would rather watch than read:</p>  <p>Flashing the Ghost TX's is currently a 1 WAY flash once you flash ExpressLRS to the TX you will not be able to use it with stock Ghost RX's (running stock firmware, they will work while running ELRS).  You will need a <code>StLink V2</code> to flash the TX</p> <p>Wire <code>3.3v</code>, <code>GND</code>, <code>CLK</code>, and <code>DIO</code> to their respective pins on your part from the StLink. (You can power with the StLink but in the first two image the radio is used to power the module).   </p> <p>Here is the output/input antennas of the TX: </p>","title":"Initial Flash"},{"location":"quick-start/tx-ghost2400/#updating","text":"<p>Updating can be done by building an updated version on the configurator and then flashing the <code>firmware.bin</code> file using OpenTX.</p>","title":"Updating"},{"location":"quick-start/tx-prep/","text":"<p></p>","title":"Preparing your Radio"},{"location":"quick-start/tx-prep/#radio-firmware-with-crsfshotmixer-sync","text":"<p>ExpressLRS requires CRSFShot or Mixer Sync to ensure full support for high packet rates. Starting with OpenTX-2.3.12, <code>CRSFshot</code> has been fully implemented, and thus you will have to update your OpenTX radio to these newer versions.</p> <p>Another alternative is EdgeTX, the bleeding edge fork of OpenTX.</p> <p>These firmwares allow flashing of <code>.elrs</code> files too.</p>","title":"Radio Firmware with CRSFShot/Mixer Sync"},{"location":"quick-start/tx-prep/#crsf-protocol","text":"<p>ExpressLRS uses the CRSF serial protocol to communicate between the transmitter and the TX module. To set this up, enter into your model settings, and on the \"Model Setup\" tab, enable your \"External RF\" and select \"CRSF\" as the protocol:</p> <p>NOTE: Make sure the internal module is turned off.</p> <p> </p> <p>NOTE: Make sure the internal module is turned off.</p>","title":"CRSF Protocol"},{"location":"quick-start/tx-prep/#serial-baud-rate","text":"<p>On some transmitters, the baud rate for comms between the opentx and the ExpressLRS module can be changed. The two rates available are 115200 and 400000. ExpressLRS supports both rates (auto switches to the correct rate on power-up), however, we have found that on the R9M 2018 modules, the inverter IC's that are used are not capable of reliably handling 400k baud. If you're using an R9M 2018 module, select 115200 baud in OpenTX, or do the resistor mod described on the R9M 2018 Resistor Mod page.</p> <p>The QX7, X10/S, X12 will also going to require the Crossfire Mod if you're going to use 400k baud rates for use with higher packet rates, particularly with the 2.4G ExpressLRS Modules. Alternatively, EdgeTX can be flashed into these Radios and have OneBit enabled.</p> <p>The X9D(plus) can't change its Max Bauds settings, but it has been found to be finicky, causing unstable packet transfers, and constant Telemetry Lost/Recovered messages from OpenTX. One fix for this is the use of the OneBit firmware or EdgeTX. Click here for more info.</p> <p></p>","title":"Serial Baud Rate"},{"location":"quick-start/tx-prep/#adc-filter","text":"<p>The ADC filter is enabled by default in OpenTX and is known to cause issues with RC Command data. This can result in \"jagged\" RC command responses in black box logs, caused by sequential RC packets that have the same command value (which were \"smoothed\" by the ADC filter). We recommend turning the ADC filter OFF in OpenTX.</p>","title":"ADC Filter"},{"location":"quick-start/tx-prep/#lua-script","text":"<p>For faster access to the Lua script, save the <code>ELRS.lua</code> File from this link: ExLRS Lua Script onto the radio's SD Card in the <code>Scripts/Tools</code> folder and Long Press the \"SYS\" button (for T16 or similar Radios) or the \"Menu\" button (for Taranis X9D or similar Radios) to access the Tools Menu where you can find ELRS script ready to run with only one click.</p> <p>Another way to get the ELRS Lua Script is via the ExpressLRS Configurator.</p> <p></p> <p>Here's how it looks in the Tools Menu:</p> <p> </p> <p>Note: For devices not yet flashed with ExpressLRS, the section below will not work.</p> <p>The Lua script has an important feature that's highly valuable with troubleshooting. On the first line, after the 6-character version hash, it shows an indicator 0:nnn which tells you how many bad UART packets and how many good UART packets per second it's getting from the radio. It can be used to confirm the communication between the Radio and the TX module is working properly. </p> <p>e.g. if you have set the Packet Rate to 200Hz, 0:200 means 0 bad packets and 200 good packets. </p> <p>The second number should match the selected packet rate (200 for 200Hz, 500 for 500Hz, etc..)</p> <p>If it doesn't and is stuck at 250 that means <code>CRSFshot</code> isn't working. Go back to the top of this page and verify you've done all the steps above correctly.</p> <p></p>","title":"Lua Script"},{"location":"quick-start/tx-prep/#troubleshooting-lua-script","text":"<p>\"Connecting\" showing on the Lua Script would mean the Protocol set for the External Module is incorrect or that the module is not properly connected to the pins of the jr bay of the radio. The latter could mean that the module's PCB has gotten loose, common with the first batches of the ES24TX modules from Happymodel.</p> <p>If the number up top the lua script is showing 0:142, etc., have a look at your model settings and make sure the internal RF module is set to off.</p> <p>The \"33e2a6\" from the photo above is the Commit Hash of the firmware version that the module has. You can reference this hash from Releases. If you can't find the commit hash from the Releases page, this could mean you are using firmware from the manufacturer's own fork of the ExpressLRS code.</p> <p>Note: on version 1.1.0 onwards pre v2.0, the version display has changed to show the format <code>{Major}{Minor}{Patch}</code>. Version 1.1.0 will show as <code>010100</code> instead of the hash e7cbb6.</p> <p>Now that your radio is set, you can now proceed with flashing ExpressLRS!</p>","title":"Troubleshooting Lua Script"},{"location":"quick-start/tx-r9m/","text":"<p></p>","title":"Flashing Frsky R9 Modules"},{"location":"quick-start/tx-r9m/#flashing-via-opentx-requires-opentx-2312-or-newer","text":"","title":"Flashing via OpenTX (Requires OpenTX 2.3.12 or newer)"},{"location":"quick-start/tx-r9m/#flashing-the-bootloader","text":"<p>The bootloader is required to be flashed first prior to flashing the ExpressLRS firmware as the bootloader will replace the factory-bootloader, and enable the hardware to instead use the ExpressLRS code.</p> <p>Using an <code>OpenTX</code> transmitter, you flash the bootloader, and then flash ELRS.</p> <p>Here is a quick 2 minute demo if you would rather watch a video than read the steps:</p>  <p>With the previous step (Preparing your Radio) done, you should now readily flash your R9 Transmitter Module.</p> <p>Copy <code>r9m_elrs_bl.frk</code> onto the SD card of your radio, in the <code>/FIRMWARE</code> folder.</p> <p>Flash <code>r9m_elrs_bl.frk</code> (14kb) to your TX module:</p> <ul> <li>Navigate in OpenTX to the TOOLS menu (hold SYS button)</li> <li>Page to the SD-HC CARD page, then the <code>FIRMWARE</code> folder</li> <li>Flash the frk file by holding OK and selecting \"Flash external module\"</li> </ul>","title":"Flashing the Bootloader"},{"location":"quick-start/tx-r9m/#flashing-the-firmware","text":"<p>Targets: </p> <ul> <li><code>Frsky_TX_R9M_via_stock_BL</code></li> <li><code>Frsky_TX_R9M_LITE_via_stock_BL</code></li> </ul> <p>In the ExpressLRS Configurator, select the correct target for your module and set your Firmware Options. </p> <p>Click on Build and wait for the firmware to be compiled. After that's done, ExpressLRS Configurator Log should show the <code>Success</code> Message, and it will automatically open the folder where the firmware.elrs can be found. Put (copy-paste) the firmware.elrs to your Radio's SD Card (preferably to the <code>/FIRMWARE</code> folder for easy access). Once on your radio, navigate to the <code>/FIRMWARE</code> folder, select the firmware.elrs and click-hold the Enter button and select \"Flash External ELRS\".</p> <p>By this point, the bootloader (r9m_elrs_bl.frk) should've been flashed already. Wait for the flashing to finish, and if your module is equipped with a speaker (full size R9Ms), you should hear the tune and two beeps (if external module is now set to CRSF protocol).</p>","title":"Flashing the firmware"},{"location":"quick-start/tx-r9m/#flashing-using-stlink","text":"<p>Targets:</p> <ul> <li><code>Frsky_TX_R9M_via_STLINK</code></li> <li><code>Frsky_TX_R9M_LITE_via_STLINK</code></li> <li><code>Frsky_TX_R9M_LITE_PRO_via_STLINK</code></li> </ul> <p>This method is an irreversible one. You will not be able to go back to Frsky firmwares with this method. You have been warned!</p> <p>This method also involves taking apart your module and soldering wires directly into its board. If you're not comfortable doing this, STOP now.</p> <p></p> <p>R9M STLink Connection</p> <p></p> <p>R9M Lite STLink Connection</p> <p></p> <p>R9M Lite Pro STLink Connection</p> <p>Wire up your module as shown above to your STLink device. This is important before any of the steps below.</p> <p>Before flashing, disable <code>'Readout Protection'</code>. To do this download the ST-LINK Utility and follow this quick how to video. After such, you can now disconnect (Target -&gt; Disconnect) and close the ST-Link Utility.</p> <p>With the module still connected to the STLink, and your Firmware Options set, hit Build &amp; Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. The ExpressLRS tune should play and then two beeps after that can be heard, for units that has a speaker (R9Ms) and if the External Module is set to CRSF Protocol.</p> <p>Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.</p>","title":"Flashing using STLink"},{"location":"quick-start/tx-siyifm30/","text":"<p></p> <p>Targets:</p> <ul> <li><code>FM30_TX_via_STLINK</code> (Initial Flash)</li> <li><code>FM30_TX_via_DFU</code> (Updating)</li> </ul>","title":"Flashing Siyi FM30"},{"location":"quick-start/tx-siyifm30/#initial-flash","text":"<p>Begin by opening the TX module by removing the 4 screws at the corners using a small phillips screwdriver. Lift the cover from the case and unscrew the antenna holder from the cover. Remove the 2 screws around the edges and remove the PCB module from the case.</p> <p>Solder 4 STLink wires to the <code>JP4</code> holes (CLK-DIO-RST-GND) and 1 wire to <code>VCC</code> pad as shown: </p> <p>Attach to an STLink as shown:</p> <p></p> <p>With the module connected shown above, and your Firmware Options set, hit Build &amp; Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay.</p> <p>Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.</p>","title":"Initial Flash"},{"location":"quick-start/tx-siyifm30/#updating","text":"<p>Plug the FM30 into the USB of your computer. Then select <code>FM30_TX_via_DFU</code> and press Build &amp; Flash to update the TX.</p>","title":"Updating"},{"location":"quick-start/tx-voyager900/","text":"<p></p>","title":"Flashing NamimnoRC Voyager"},{"location":"quick-start/tx-voyager900/#flashing-via-wifi","text":"<p>Target: <code>NamimnoRC_Voyager_900_TX_via_WiFi</code></p>","title":"Flashing via Wifi"},{"location":"quick-start/tx-voyager900/#method-1","text":"<p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>firmware.elrs</code> file is. Do not close this window so you can easily locate the correct file to upload to the module.</p> <p>These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The <code>Wifi Update</code> option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead.</p> <p>Attach the module to your JR Bays and power it up. Connect to the <code>ESP Wifi Manager</code> Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). </p> <p></p> <p>Press <code>Configure WiFi</code> and set your home network SSID and password. This will enable your Tx Module to connect to your local home network.</p> <p>On your browser, refresh the http://elrs_tx.local/ and scroll towards the STM32 Firmware Update section, as shown below:</p> <p></p> <p>Drag-and-drop the <code>firmware.elrs</code> file created by the ExpressLRS Configurator into the Choose File field, or manually navigate to the Folder by clicking the Choose File button. You can also upload the <code>firmware.bin</code> file but change the offset to 0x4000. Once the correct file is selected, click the <code>Upload and Flash STM32</code>. Wait for the process to complete, and the module will reboot (~2-3min). Using the ELRS.lua script, verify that you have the latest version.</p>","title":"Method 1"},{"location":"quick-start/tx-voyager900/#method-2","text":"<p>These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The <code>Wifi Update</code> option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead.</p> <p>Attach the module to your JR Bays and power it up. Connect to the <code>ESP Wifi Manager</code> Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). </p> <p></p> <p>Press <code>Configure WiFi</code> and set your home network SSID and password. This will enable your Tx Module to connect to your local home network.</p> <p>Using the ExpressLRS Configurator, select the correct Target and set your Firmware Options. Click Build and Flash and wait for the compile process to complete. You should see a section as pictured below and the Success message marking the update process complete.</p> <p></p> <p>Using the ELRS.lua script, verify that you have the latest version.</p>","title":"Method 2"},{"location":"quick-start/tx-voyager900/#flashing-via-opentx-radio","text":"<p>Note: The <code>NamimnoRC_Voyager_900_TX_via_WiFi</code> Target will work for this method too!</p> <p>With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the <code>NamimnoRC_Voyager_900_TX-&lt;version&gt;.elrs</code> file is. Do not close this window so you can easily locate the correct file to copy to your Radio SD Card.</p> <p>Copy the <code>NamimnoRC_Voyager_900_TX-&lt;version&gt;.elrs</code> file into your radio's SD Card <code>/FIRMWARE</code> folder.</p> <p>Once copied, navigate to the <code>/FIRMWARE</code> Folder on your Radio and select/highlight the <code>NamimnoRC_Voyager_900_TX-&lt;version&gt;.elrs</code> file, long-press the Enter key and select <code>Flash external ELRS</code>. Radio should show a <code>Flash Successful</code> message and you're done!</p> <p>Using the ELRS.lua script, verify that you have the latest version.</p>","title":"Flashing via OpenTX Radio"},{"location":"quick-start/tx-voyager900/#flashing-via-stlink","text":"<p>Target: <code>NamimnoRC_Voyager_900_TX_via_STLINK</code></p> <p>ONLY USE THIS METHOD IF THE FIRMWARE HAS BEEN CORRUPTED </p> <p>Begin by disassembling the module by unscrewing the 4 screws at the rear of the module with a 1.5mm hex wrench. Carefully seperate the parts of the module and detach the cable from the main PCB.</p> <p> </p> <p>Wire your <code>STLink v2</code> to the module's pins as show below:</p> <p></p> <p>With the module connected shown above, and your configuration set, hit Build &amp; Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. If the Radio has CRSF selected, the light should turn green meaning the module has communication with your radio.</p> <p>Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.</p>","title":"Flashing via STLink"},{"location":"quick-start/unbricking/","text":"<p></p>","title":"Unbricking"},{"location":"quick-start/unbricking/#help-i-bricked-my-rx","text":"<p>Take a breath, calm down, relax. If you\u2019ve had a failed update your RX or TX might be in a non-working state. The good news is that unless the hardware is damaged, it\u2019s impossible to brick any of the ExpressLRS hardware. ANY of the hardware can be recovered using the serial passthrough feature of a flight controller, or with a usb-serial adapter. </p> <p>Let\u2019s start with the RX\u2019s, since they are usually the trickiest. There are two main classes of receivers. STM32 based and ESP8285 based. If you\u2019re not sure, you probably have an ESP8285 based RX. The main difference is that the STM32 RX\u2019s don\u2019t have WiFi. </p> <p>Now, ALL the ESP8285 based RX\u2019s have a factory installed bootloader onboard which CANNOT be damaged or tampered with. You can completely screw up the upgrade and always get it back using this default bootloader. </p> <p>First, we must stop betaflight getting in the way and screwing things up with telemetry. Load up the configurator, go to the configuration page and then disable telemetry. Press save and reboot. If not already done so, the RX must be wired to the Flight controller or a USB-SERIAL adapter. </p> <p>Take note that the RX wires goes to the TX and vice versa, BOTH wires must be connected. If your receiver was already working properly and it\u2019s still wired in you\u2019ve already done this step.</p> <p>Next, we must activate the ROM bootloader. On every ESP8285 based RX there is a GPIO0 pin somewhere on the board, it may be connected to a button, or it may be a bare pad on the PCB. You must connect this pin to ground, THEN apply power. If you\u2019ve done it right the LED should be solid on. How exactly this is done depends on the type of receiver:</p> <ul> <li>If you have a receiver with a button, just hold it down while you apply power to enter the bootloader. Keep holding the button until the configurator starts uploading to the RX.</li> <li>If you have an EP1/EP2 you have to short the boot pad which is located just above GND to GND with solder. </li> </ul>","title":"HELP I BRICKED MY RX!"},{"location":"quick-start/unbricking/#happymodel-ep1-ep2-boot-pads","text":"<p></p> <p>Once the receiver is in bootloader mode, all you need to do is configure the RX in the configurator as per normal and then upload with the \u2018via_BetaflightPassthrough\u2019 method. If all goes well, you should see it upload successfully. </p> <p>If you\u2019ve still got the boot pad bridged with solder, you\u2019ll need to remove the solder before it will work again. Congratulations! You\u2019ve unbricked your receiver, go fly!</p>","title":"Happymodel EP1, EP2 boot pads:"},{"location":"software/obsolete-defines/","text":"<p></p> <p>This page contains old user_defines.txt that have been removed or superseded by new defines.</p> <p>New items should be added to the top of the list so the last entry here is the oldest. The order of each entry should be [code]definename[/code] followed by the original text of the documentation, ending with a separate paragraph \"REMOVED [version] [replacement or reason for removal]\".</p>","title":"Obsolete Defines"},{"location":"software/obsolete-defines/#obsolete-defines","text":"<p><pre><code>-DFAST_SYNC\n</code></pre> Option that adds faster initial syncing, by changing how long the receiver waits for a connection in each mode while not connected. This option is now the default, but disabling it can help syncing at lower packet rates (50Hz and below).</p> <p>REMOVED 1.0.0-RC2 initial sync replaced with a full FHSS period wait</p> <p><pre><code>#-DR9M_UNLOCK_HIGHER_POWER \n</code></pre> REMOVED 1.0.0-RC1 replaced with generic <code>-DUNLOCK_HIGHER_POWER</code></p> <p><pre><code>#-DARM_CHANNEL=AUX1\n</code></pre> If you are using a different channel than the default you need to edit \ud83d\udd25 (or you may not be able to gain sync safely - default is listed in <code>#DARM_CHANNEL</code> as AUX1 which is Channel 5).</p> <p>NB This feature assumes that a low value of the arm switch is disarmed, and a high value is armed. If you have the arm switch reversed it will not work correctly and the link won't be established. For this reason it may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion.</p> <p>REMOVED 1.0.0-RC1 AUX1 is always the arm switch now, no longer configurable</p> <p><pre><code>#-DLOCK_ON_50HZ\n</code></pre> <code>LOCK_ON_50HZ</code> locks the RX at <code>50Hz</code> mode from the powerup. (Only recommended for longrange, and partly redundant with previous feature.) Merged in Pull 143</p> <p>REMOVED 1.0.0-RC1 not sure why this was removed</p> <p><pre><code>-DAUTO_WIFI_ON_BOOT\n</code></pre> REMOVED 1.0.0-RC1 replaced with <code>-DAUTO_WIFI_ON_INTERVAL=X</code></p>","title":"Obsolete Defines"},{"location":"software/open-ocd/","text":"<p></p> <p>If you are using Linux then you can't use the ST-LINK utility from st.com. But fortunately you can achieve the same effect with openocd on the Linux command line. This tutorial assumes you have an STLink v2.</p> <ol> <li>Install openocd from your distro's repository. For Debian/Ubuntu use: <code>sudo apt-get install openocd</code></li> <li> <p>Issue the full command:</p> <p>a. For R9mm/Mini <code>openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c 'init; reset halt; stm32f1x unlock 0; reset run; shutdown'</code></p> <p>b. For Ghost \u00c1tto/Zepto <code>openocd -f interface/stlink-v2.cfg -f target/stm32f3x.cfg -c 'init; reset halt; stm32f3x unlock 0; flash protect 0 0 last off; reset halt; exit'</code></p> </li> <li> <p>Restart your device so the disabled readout protection can take effect.</p> </li> <li>Now you can proceed with flashing your receiver. This may work on other devices or it might not.</li> </ol>","title":"OpenOCD for STLink"},{"location":"software/stlink-fix/","text":"<p></p> <p>PlatformIO has an older version of STLink. It is unable to communicate with the STM32L MCUs on some Rx's. Affected RX's: -(DIY) PP</p> <p>Swapping out PIO's STLink folder contents with the current STLink will allow using the configurator with these RX's.</p> <p>Go to your STLink folder </p> <ul> <li>copy contents of \"ST-Link Utility\" <code>C:\\Program Files (x86)\\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility</code></li> </ul> <p></p> <ul> <li>paste files from \"st-link utility\" folder into \"stlink\" folder in your users PIO location <code>C:\\Users\\username\\ .platformio\\packages\\tool-stm32duino</code></li> </ul> <p></p>","title":"PIO STLink Fix"},{"location":"software/switch-config/","text":"<p></p> <p>This documentation applies to versions above 1.0.0-RC1</p> <p> Put your arm switch on AUX1 </p> <p>ExpressLRS has two options for how switches are transmitted: Normal mode and <code>HYBRID_SWITCHES_8</code>. The switch mode selected MUST match (select either Option 1 or Option 2) between the TX module and RX.</p> <ol> <li>The default choice is to have 8x 2-position switches. \ud83e\udd48 That's really about all there is to this mode, other than noting that you should have your arm switch on AUX1. ExpressLRS uses AUX1 to determine if your model is armed.</li> </ol>    Channel Resolution Frequency     AUX1 1-bit / 2-position Every packet, ARM channel   AUX2-AUX8 1-bit / 2-position Every packet    <ol> <li>The other option is <code>HYBRID_SWITCHES_8</code> where the switches are broken into different types</li> </ol>    Channel Resolution Frequency     AUX1 1-bit / 2-position Every packet, ARM channel   AUX2-AUX7 3-bit / 2-position, 3-position, or 6-position Round-robin   AUX8 4-bit / 16-position Round-robin    <p>The first switch (AUX1) is sent with every packet. Put. Your. Arm. On. AUX1. For the remaining 7 switches, one switch is sent with each packet (in addition to AUX1). When a switch changes, it is given priority to be sent in the next packet to try to reduce its latency. </p>","title":"Switch Configs"},{"location":"software/switch-config/#aux-1","text":"<p> Put your arm switch on AUX1 . AUX1 is the low-latency switch, sent with every packet, and only supports on/off (2-position) operation. ExpressLRS uses AUX1 to determine if your model is armed, and should set up on the transmitter so that ~1000 is disarmed, ~2000 is armed.</p>","title":"AUX 1"},{"location":"software/switch-config/#aux-2-7","text":"<p>The majority of the aux channels, AUX2 - AUX7, work with 2-position switches, 3-position switches, or 6-position switches / selector buttons.</p>    Approx. Channel Input (us) Channel Output (us) Ardupilot Mode     988 1000 Mode1 (up position for 2-pos / 3-pos)   1192 1275 Mode2   1398 1425 Mode3   1500 1500 Mode4 (center position in 3-pos)   1602 1575 Mode4   1807 1725 Mode5   2011 2000 Mode6 (down position for 2-pos / 3-pos)","title":"AUX 2-7"},{"location":"software/switch-config/#aux-8","text":"<p>AUX8 is the wide range channel, supporting 16 positions. You can stack all your modes in here, Bardwell style, or get some low-res camera pan action-- 180 degrees / 16 actually isn't terrible. Clever math-heads might note that there's no \"center position\" (1500us) in a 16-position switch, so using AUX8 with a 3-position switch means it will come out as 1533 at the flight controller.</p>    Switch Position Channel Output (us) Switch Position Channel Output (us)     0 1000 8 1533   1 1066 9 1600   2 1133 10 1666   3 1200 11 1733   4 1266 12 1800   5 1333 13 1866   6 1400 14 1933   7 1467 15 2000","title":"AUX 8"},{"location":"software/switch-config/#faq","text":"","title":"FAQ"},{"location":"software/switch-config/#why-do-you-keep-saying-put-arm-on-aux1","text":"<p>For safety reasons.</p> <p>In HYBRID_SWITCHES_8 mode, AUX1 is sent with every packet going out, this is the most reliable way to be able to tell your model to disarm. If your arm switch is in another aux channel, it may be several packets before that switch is transmitted, and there's no guarantee that the RX will actually receive that packet. There's a non-trivial chance your model may not ever disarm if the link quality is low and it just so happens that the packet containing the arm switch is getting missed every time. Forcing the arm switch into every packet on AUX1 means that if any packet is received by ExpresLRS, it will disarm your model, not just a less than 1-in-7 chance.</p> <p>It also protects against unintentional disarms caused by a corrupt packet changing the value of the arm switch to disarmed. Betaflight requires that 4x \"disarm\" commands are received before disarming to guard against this possibility. With arm on AUX1, a single corrupt packet can not disarm your model. With arm on AUX2-8, the one corrupt switch value will be sent 6 times before the value is refreshed, but the flight controller would have already disarmed by that point.</p>","title":"Why do you keep saying \"put arm on AUX1\"?"},{"location":"software/switch-config/#i-use-a-3-pos-switch-for-arm-this-software-is-unusable","text":"<p>You can still use a 3-position switch to arm! AUX1 just needs to be 2-position, not the physical switch. Simply adjust the mixer in your transmitter so AUX1 works like an on-off switch. If your 3-position arm switch had a second function as well, such as enabling Blackbox, just use one of the other 7 AUX channels to send the switch on a second channel.</p>","title":"I use a 3-pos switch for arm, this software is unusable"},{"location":"software/switch-config/#why-cant-i-have-switches-potentiometers-with-full-10-bit-resolution","text":"<p>A lot of the magic of ExpressLRS comes from its small packet sizes, there simply is not enough space to put all that data. There are tricks that can be done with interleaving sticks and switches packets but we believe sticks should be in every packet for the lowest control latency. Different switch modes with higher resolution may be added further down the road for setups where higher latency doesn't matter.</p>","title":"Why can't I have switches / potentiometers with full 10-bit resolution?"},{"location":"software/toolchain-install/","text":"<p></p> <p>Note: The following section is intended for advanced users who intend to dabble with the source code directly.</p>","title":"Toolchain Setup"},{"location":"software/toolchain-install/#toolchain-setup-advanced","text":"<p><code>ExpressLRS</code> is written in C++ using the Arduino framework. </p> <ul> <li>Rather than using the Arduino IDE (which let's face it, \ud83d\uddff is pretty clunky), we use platformio</li> <li>To ease the use of <code>pio</code> we recommend to use the according extension for <code>Visual Studio Code</code></li> </ul>","title":"Toolchain Setup (Advanced)"},{"location":"software/toolchain-install/#platformio","text":"<ol> <li>\ud83d\udd3d Download a copy of vscode for your computer </li> <li>\ud83d\udcc2 Open vscode, and click on the \"Extensions\" icon in the toolbar on the right (see Managing Extensions \ud83d\udcd8)</li> <li>\ud83d\udd0e In the search box, enter <code>platformio</code>, and install the extension (see the <code>pio install</code> documentation \ud83d\udcda)</li> </ol>","title":"PlatformIO"},{"location":"software/toolchain-install/#git-setup","text":"<p>We recommend using VSCode's built-in Git client, as it requires the least 3rd party software \ud83e\udd16.</p> <ol> <li>\ud83d\udd3d Download a copy of git (this is also needed for <code>PlatformIO</code>)</li> <li>Install <code>git</code>, click yes to the default options (there are a LOT \ud83d\udcaf)</li> <li>IMPORTANT! Make sure you select this option during install, it adds git to PATH which is necessary for VScode cloning (the next step). </li> </ol> <p></p>","title":"Git Setup"},{"location":"software/toolchain-install/#cloning-the-repo","text":"<ul> <li>In VSCode open the <code>command pallete</code> (using <code>Cmd+Shift+P</code> on MacOS or <code>Ctrl+Shift+P</code> on Windows)</li> <li>Enter <code>Git: Clone</code> </li> </ul> <p></p> <ul> <li>Click that! \ud83d\udc48 </li> <li>Then, enter ExpressLRS Repo URL -&gt; <code>https://github.com/AlessandroAU/ExpressLRS.git</code> \ud83d\udcbb </li> <li>Choose a folder for ExpressLRS. \ud83d\udcc2 </li> </ul>","title":"Cloning the Repo"},{"location":"software/toolchain-install/#selecting-the-latest-release","text":"<p>Before we can do any building, you need to select a release build of ELRS. For example, release 0.1.0-RC1. In Visual Studio Code select that tag. The location of the selector is shown below. \ud83d\uddb1\ufe0f </p> <p> </p> <p>Click the selector, and then type in the name of the tag, in this case <code>0.1.0-RC1</code>. </p>","title":"Selecting the Latest Release"},{"location":"software/toolchain-install/#platformio-building","text":"<p>Once you had the time of your life setting up your toolchain \ud83e\uddf0 you are ready to Flash \u26a1 ExpressLRS to supported hardware.</p>","title":"PlatformIO Building"},{"location":"software/toolchain-install/#building-targets-using-platformio","text":"<ol> <li>\ud83d\udcc2 When you first launch <code>Visual Studio Code</code>, you should see the <code>PlatformIO Home Page</code> in a tab. Click the <code>Open Project</code> button. Navigate to the <code>ExpressLRS</code> repo directory. Navigate into the <code>src</code> folder (i.e. <code>./ExpressLRS/src/</code>). Finally, press the <code>Open</code> button.</li> <li>\u270f\ufe0f Edit the file <code>./src/user_defines.txt</code> to define user specific variabls. \ud83d\ude08 Please make sure you did edit the file according to your needs! </li> <li>\ud83d\udcca In the toolbar on the left, click the PlatformIO icon, which will show the list of tasks. Now, select Project Tasks, expand your desired target and select Build/Upload (depending on the method). You should see the result in the terminal.</li> <li>\ud83d\ude43 If something went wrong - please check the <code>Terminal</code>, too. It will contain at least a hint on what the issue is. Please ask the community for further help\ud83e\uddd1\u200d\ud83d\udd27!</li> </ol>","title":"Building Targets using PlatformIO"},{"location":"software/toolchain-install/#updating-your-local-repo","text":"<p>You've cloned the repository and are now wondering how to get new updates down the line? Then this document is meant for you! Here's a primer on how to keep your local copy of the repository up-to-date.</p>","title":"Updating your Local Repo"},{"location":"software/toolchain-install/#method-1-the-clean-way-fetch-reset","text":"<p>Probably the easiest and least troublesome method, however, it'll overwrite any changes you've made to your local copy. </p> <ol> <li> <p>Open the terminal</p> <p>You can either straight up open <code>bash/cmd</code> and navigate to your project folder or open an integrated terminal in VSCode:</p> <ul> <li>Open the <code>command pallete</code> (using <code>Cmd+Shift+P</code> on MacOS or <code>Ctrl+Shift+P</code> on Windows)</li> <li> <p>Enter: <code>Create New Integrated Terminal</code></p> <p></p> </li> </ul> </li> <li> <p>In the terminal, type: <code>git fetch -pu &amp;&amp; git reset --hard origin/master</code></p> <p>This will get you the latest version and destroy any local changes you've made.</p> </li> </ol>","title":"Method 1: The Clean Way - Fetch &amp; Reset"},{"location":"software/toolchain-install/#method-2-the-lazy-way-commit-pull-merge","text":"<p>The advantage this method has over the first method is that all your changes to the user_defines.txt (or any other file, for that matter) will get merged together with any new updates. There's a possibility that, if changes are too big, you could end up with a merge conflict. If that doesn't appeal to you, stick to the first method.</p> <ol> <li> <p>Commit your changes to your local repository</p> <ul> <li>In VSCode open the <code>command pallete</code> (using <code>Cmd+Shift+P</code> on MacOS or <code>Ctrl+Shift+P</code> on Windows)</li> <li> <p>Enter: <code>Git: Commit</code></p> <p>VSCode will tell you that there are unstaged changes and ask if you want to add them to the commit. Confirm this! This will just commit your changes to the user_defines.txt to your local repository. No worries, you're not overwriting anything on github! :octocat:</p> </li> </ul> </li> <li> <p>Open the terminal, how-to is detailed in method 1</p> </li> <li> <p>In the terminal, type: <code>git pull -f</code></p> <p>This will pull a new revision of the remote repository to your own local repository and automatically merge it with your own changes.</p> </li> </ol>","title":"Method 2: The lazy way - Commit, Pull &amp; Merge"},{"location":"software/user-defines/","text":"<p></p>","title":"User Defines"},{"location":"software/user-defines/#user-defines-explained","text":"<p>With more features being added consistently, <code>./src/user_defines.txt</code> has gotten complicated \ud83e\udd37\u200d\u2642\ufe0f. So we will break it down! \ud83d\udd28 </p> <p>*Note: This is the full list of currently supported User Defines and would help you should you intend to compile the firmware using the Toolchain or Manual Mode on the ExpressLRS Configurator.</p>","title":"User Defines Explained"},{"location":"software/user-defines/#defines-101","text":"<ul> <li>To enable/disable anything in the user defines, simply add or remove a <code>#</code> in front of anything that has a <code>-D</code>.</li> <li>We recommend reading this page in its entirety before first flashing \u26a1 to have a better sense of the options.</li> </ul>","title":"Defines 101"},{"location":"software/user-defines/#binding-phrase","text":"<p><pre><code>-DMY_BINDING_PHRASE=\"default ExpressLRS binding phrase\"\n</code></pre> This step is simple but important. Both the TX and RX NEED to have the same binding phrase or ExpressLRS WILL NOT WORK. Anyone using the same binding phrase as you will be able to control your model, so be unique. Set something memorable, and limit to alphanumeric phrases conforming to the Latin alphabet*. Receivers flashed with firmware builds that do not have binding phrase enabled will support and require the traditional binding method. \ud83d\udcdc </p> <p>* This phrase gets md5 hashed and gets built into the binary you will be flashing.</p>","title":"Binding Phrase"},{"location":"software/user-defines/#regulatory-domain","text":"<p><pre><code>#-DRegulatory_Domain_AU_915\n#-DRegulatory_Domain_EU_868\n#-DRegulatory_Domain_AU_433\n#-DRegulatory_Domain_EU_433\n#-DRegulatory_Domain_FCC_915\n#-DRegulatory_Domain_ISM_2400\n</code></pre> This is a relatively simple one - enable whatever regulatory domain you are in. <code>EU 868</code> \ud83c\uddea\ud83c\uddfa  is compliant to the frequency but is not LBT compliant \ud83d\udc42 . Every other band is near compliant \ud83d\udc7f  but may not be fully compliant for your regulatory domain. </p>","title":"Regulatory Domain"},{"location":"software/user-defines/#telemetry","text":"<p><pre><code>#-DENABLE_TELEMETRY\n</code></pre> Enable advanced telemetry support. This option must be enabled on both TX and RX. The following telemetry messages are supported:</p> <ul> <li>GPS</li> <li>BATTERY_SENSOR</li> <li>ATTITUDE</li> <li>DEVICE_INFO</li> <li>FLIGHT_MODE</li> <li>MSP_RESP</li> </ul> <p>Note 1: Increase the telemetry rate with the ExpressLRS lua script. Increase the rate until the sensor lost warnings go away. It is normal to set it up to 1:16 with 200 Hz refresh rate.</p> <p>Note 2: It must be enabled together with HYBRID_SWITCHES_8.</p> <p><pre><code>#-DTLM_REPORT_INTERVAL_MS=320LU\n</code></pre> It makes the TX module send the telemetry data to the OpenTX every 320 ms by default. This stops the telemetry lost warnings when running a high telemetry ratio, or low rates like 50hz.</p> <p>Default value is 320LU. If you want to change that you have to suffix your milliseconds value with LU. For example, in order to specify 100 ms telemetry update rate you have to enter it like this: 100LU.</p> <p>Typically, you want to keep 320LU value for OpenTX based radios, and 100LU for ErskyTx ones.</p>","title":"Telemetry"},{"location":"software/user-defines/#switches","text":"<p><pre><code>#-DHYBRID_SWITCHES_8\n</code></pre> Changes how the AUX channels are sent over the air. The default option is Normal Mode with 8x 2-position low-latency switches. Enabling <code>HYBRID_SWITCHES_8</code> changes this to 1x 2-pos + 6x 7-pos + 1x 16-pos, with only the 2-position being low-latency. In Normal Mode, all switches are sent with every packet, in Hybrid Mode, only AUX1 is sent with every packet and the rest are rotated through. Note: The switch mode MUST match between the RX and TX. A detailed explanation of the differences between the two options can be found in Switch Modes, but   1. If only two position switches are needed, and they must be updated as fast as possible: Normal Mode   2. Almost everyone: Hybrid Mode (Put ARM on AUX1)</p>","title":"Switches"},{"location":"software/user-defines/#output-power-limit","text":"<p>There has been some reports of the R9M modules showing instability at &gt;250mw with stock cooling. This in part because the ELRS uses a higher duty cycle for transmission compared to stock firmware. By default the power of any TX is limited to 250mw but you can unlock up to 1000mw (for hardware that supports it) by enabling the following option. Do this at your own risk if you make no cooling modifications-- R9M modules will burn themselves out without cooling.</p> <p><pre><code>#-DUNLOCK_HIGHER_POWER \n</code></pre> We published R9M Fan Mod Cover, a custom 3d printed backplate with room for a fan and extra cooling to allow for maximum power (1-2W depending on the mod).</p> <p></p>","title":"Output Power Limit"},{"location":"software/user-defines/#performance-options","text":"<p><pre><code>#-DNO_SYNC_ON_ARM\n</code></pre> no sync on arm doesn't transmit sync packets while armed. This is useful for racing as there is less time &amp; packets wasted \ud83d\uddd1\ufe0f on sending sync packets. HOWEVER if you are doing serious long range \u26f0\ufe0f, keep this commented because in the case of a sustained failsafe, link can not be regained while armed.</p> <p>AUX1 is the channel ExpressLRS uses to detect \"ARMED\", and this feature assumes that a low value of the arm switch is disarmed, and a high value is armed. OpenTX can invert your switch if you prefer it to be mechanically inverted. It may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion.</p> <p><pre><code>-DFEATURE_OPENTX_SYNC\n#-DFEATURE_OPENTX_SYNC_AUTOTUNE\n</code></pre> These features enable lower latency \ud83c\udfc3\u200d\u2642\ufe0f and offset from the OpenTX radio to the TX. The first lowers latency and should be kept enabled. The second is more experimental and can lower the offset from the radio by tuning it as close as possible to <code>0</code>, but is experimental (even in 1.0) and is best left disabled. </p> <p>Both require OpenTX <code>2.3.12</code> or above. In order to install it, you will have to use OpenTX companion application. </p> <p>Deviation radio users such as those with the T8SGv2/v3 should disable this feature.</p> <p>You can also use EdgeTX.</p> <p><pre><code>-DLOCK_ON_FIRST_CONNECTION\n</code></pre> RF Mode Locking - When the RX is waiting for a connection, it cycles through all available rates waiting for a connection on each one. By default, ExpressLRS will go back to this mode after a disconnect (failsafe). If <code>LOCK_ON_FIRST_CONNECTION</code> is used, ELRS will not cycle after a disconnect, but instead just stay on whatever rate the last connection was. This makes connection re-establishment quick, because the RX is always listening at the proper rate. This is generally what everyone wants, but there is utility in being able to switch the TX to the lowest rate to get more range to re-establish a link with a downed model, which can't happen if the RX is locked at the previous rate.</p> <p>When cycling through the rates, the RX starts with the fastest packet rate and works down to the slowest, then repeats. It waits <code>PACKET_INTERVAL * PACKS_PER_HOP * HOP_COUNT * 1.1</code> at each rate. Example: 4ms * 4 * 80 * 1.1 = 1.408s for 250Hz. The duration is extended 10x if a valid packet is received during that time. Even with <code>LOCK_ON_FIRST_CONNECTION</code>, the rate can be changed by changing the TX rate using ELRS.lua while connected, or by power cycling the RX.</p> <p><pre><code>#-DUSE_DIVERSITY\n</code></pre> Enable antenna-switching diversity for RX that support it.</p>","title":"Performance Options"},{"location":"software/user-defines/#compatability-options","text":"<p><pre><code>-DUART_INVERTED\n</code></pre> This only works with <code>ESP32</code> based TXes (will not work with modules without built-in inversion/uninversion), but enables compatibility with radios that output inverted CRSF, such as the FrSky QX7, TBS Tango 2, RadioMaster TX16S. You want to keep this enabled in most of the cases. If your radio is T8SG V2 or you use Deviation firmware turn this setting off. <pre><code>-DUSE_UART2\n</code></pre> This enables integration with Jye's FENIX rx5805 pro-diversity module \ud83d\udc77 </p> <p><pre><code>#-DUSE_R9MM_R9MINI_SBUS\n</code></pre> This does not turn on SBUS protocol it simply changes the pin used for communication from those two side pins (A9 and A10) to use the pin labeled \"SBUS\" on the RX, which is inverted. This is useful for <code>F4 FCs</code> which only have an inverted receiver input UART RX. \ud83d\udd3c. This is only one way, so you lose the telemetry downlink to your radio as well as passthrough flashing. Enabling this turns on CRSF protocol output on the <code>S.BUS</code> \ud83d\ude8c pin on your <code>R9MM/R9Mini</code>. <code>set serialrx_inverted = ON</code> may also be needed within Betaflight \ud83d\udc1d for compatibility</p>","title":"Compatability Options"},{"location":"software/user-defines/#other-options","text":"<p><pre><code>-DAUTO_WIFI_ON_INTERVAL=30\n</code></pre> \u26a0\ufe0f Must be defined if you plan to update your RX over wifi without using a button on the RX \u26a0\ufe0f This will automatically turn the wifi \ud83d\udcf6 on for any module that has an <code>ESP8285</code> on it if no TX connection is established after N seconds from boot (the 30 is the time). This enables pushing firmware updates to the RX by connecting to its wifi network and visiting <code>http://10.0.0.1</code>.</p> <p><pre><code>#-DJUST_BEEP_ONCE\n#-DMY_STARTUP_MELODY=\"&lt;music string&gt;|&lt;bpm&gt;|&lt;semitone offset&gt;\" -or-\n#-DMY_STARTUP_MELODY=\"&lt;rtttl string&gt;\"\n</code></pre> For TXes like the R9M, this sets if the TX only beeps one-time versus playing a startup song. Currently, it is set to play the startup song \ud83c\udfbc , but if you don't prefer it, uncomment this to turn it off. \u2716\ufe0f</p> <p>For all your customization needs, use <code>DMY_STARTUP_MELODY</code> to define your own startup melody using the BlHeli32 or RTTTL syntax. For BLHeli32, the parameters <code>music string</code> and <code>bpm</code> are required, whereas <code>semitone offset</code> is optional to transpose the entire melody up or down by the defined amount of semitones.</p> <p>Example BlHeli32 melodies are available on Rox Wolfs youtube channel, some experimentation may be required though.  To write your own melody, this (Sheet Music 101) and this (BLHeli Piano) are useful resources.</p> <p>The build process also supports RTTTL-formatted ringtone strings. RTTTL melodies are delimited by colons <code>:</code> and start with a description versus the BLHeli style with have pipes <code>|</code>. e.g. <code>Mario:d=4,o=5,b=100:32p,16e6,16e6,16p,16e6,16p,16c6,16e6,16p,16g6,8p,16p,16g</code></p> <p><pre><code>-DUSE_ESP8266_BACKPACK\n</code></pre> This enables communication with the ESP Backpack for over-the-air updates (<code>env:FrSky_TX_R9M_via_WiFi</code>) \ud83d\udda5\ufe0f and debugging via WebSocket \ud83d\udd0d. Uncommented by default, does not need to be changed.</p>","title":"Other Options"},{"location":"software/user-defines/#obsolete-user_defines","text":"<p>See Obsolete user_defines</p>","title":"Obsolete user_defines"},{"location":"software/updating/betaflight-passthrough/","text":"<p></p>","title":"Updating through BF Passthrough"},{"location":"software/updating/betaflight-passthrough/#general-instructions","text":"<p>Once you have Flashed ELRS onto your receivers they can be conveniently updating using the passthrough feature of Betaflight (and similar FC FW). This is a relatively simple process.</p> <ol> <li>Open VS Code or the configurator and prepare to compile and upload.  </li> <li>Plug in your FC to your computer, but do NOT connect to betaflight configurator.  </li> <li>Select <code>env:YOUR_RX_via_Betaflight_Passthrough</code> and hit upload.  </li> <li>That's it!</li> </ol>","title":"General Instructions"},{"location":"software/updating/betaflight-passthrough/#esp-specific-instructions","text":"<p>Since 1.0.0, ESP receivers can be updated via passthrough without using the boot button as long as the firmware is not corrupted. If you're unable to get it to work, your firmware might be corrupted, in which case you'll need to temporarily turn off the telemetry feature in betaflight. If it still doesn't work, the bootloader might be messed up and the following steps should work.</p> <ol> <li>Open VS Code or the configurator and prepare to compile and upload.  </li> <li>Plug in your FC to your computer, but do NOT connect to betaflight configurator and no NOT power the RX. If your RX gets powered from USB, desolder the power wire so that you can manually power it up independently of the flight controller.  </li> <li>Hold the boot button of the RX or jump the boot jumper.  </li> <li>Select <code>env:YOUR_RX_via_Betaflight_Passthrough</code> and hit upload.  </li> <li>Wait for the command line to show <code>.....-----</code>.  </li> <li>Plug in a battery or otherwise power up the RX.</li> </ol>","title":"ESP-Specific Instructions"},{"location":"software/updating/betaflight-passthrough/#troubleshooting","text":"<ul> <li>If it fails to flash (may display a success message but has errors show up above the final success output), check if it is flashing the correct COM. Sometimes an ethernet adapter on your motherboard will populate a COM port, which will confuse the script and it will attempt to flash to that COM. </li> <li>The solution that could work would be manually editing the <code>UARTUpload.py</code> and <code>BetaflightinitPassthrough.py</code> files in <code>src/python</code>.</li> <li>Another possible solution could be changing the COM to a higher number for the unnecessary COMs </li> <li>Sometimes the boot jumper or button must be used while powering up the receiver.</li> </ul>","title":"Troubleshooting"},{"location":"software/updating/betaflight-passthrough/#ardupilot-instructions-community-contribution-untested","text":"<p>Connect the autopilot to a PC using a USB cable and connect with a Ground Station (i.e. Mission Planner, QGC, etc). Set SERIAL_PASSTIMO to a length of time (in seconds) that gives you enough time to connect with the sensor\u2019s configuration software. 30 to 60 seconds is a good choice Set SERIAL_PASS2 to the number of the serial port connected to the sensor. I.e. \u201c2\u201d if the sensor is connected to Telem2/Serial2. Be sure to set each port\u2019s baud rate appropriately using the SERIALx_BAUD parameter. The rates may be different for each port. ArduPilot will do the buffering. Press the \u201cDisconnect\u201d button on the ground station but leave the USB cable from the PC to the autopilot connected. Open the sensor\u2019s configuration software and connect to the autopilot\u2019s COM port. If all goes well the configuration software should work as it does when the PC is directly connected to the sensor If the configuration fails to connect there are some things to try: Some configuration software will not allow connecting to the autopilot\u2019s COM port by default but may have a option to display all available COM ports If no serial messages are received from the PC the timeout will expire and SERIAL_PASS2 will revert to -1 https://ardupilot.org/.../common-serial-passthrough.html</p>","title":"Ardupilot Instructions (community contribution, untested)"},{"location":"software/updating/wifi-updating/","text":"<p></p> <ol> <li>Build your fimware and locate your <code>firmware.bin</code> file (this may be named something else if someone built it for you but that's fine)  </li> <li>Put your device in Wi-Fi updating mode \ud83d\udcf6    a. For TX, open LUA script on the handset and select \"Wi-Fi Update\"    b. For RX, power the receiver by plugging in a battery or USB and wait for LED to be blinking fast \ud83d\ude48  </li> <li>Connect to the Wi-Fi network from your computer with the password <code>expresslrs</code>    Note 1: Some receivers have very weak Wi-Fi antennas so they will have to be extremely close to the computer's Wi-Fi antenna.    Note 2: If a window pops up automatically when you connect to the Wi-Fi , close it and use a regular browser window instead.  </li> <li>Open a browser tab and navigate to <code>http://10.0.0.1</code> </li> <li>Click \"Choose File\"  </li> <li>Select <code>firmware.bin</code> from your latest build(eg: ...ExpressLRS\\src.pio\\build\\[target]\\firmware.bin)  </li> <li>Click \"Update\"  </li> <li>Wait for the page to refresh and your URL bar to say 10.0.0.1/update (it'll look like the page is frozen for a bit)</li> <li>WAIT AT LEAST 10 SECONDS after the page refreshes indicating the upload is complete. It takes time for the firmware to flash after the upload, so do not pull the power until you see activity on the LED of the device or you will soft brick your device due to pulling power mid-flash.</li> </ol> <p>Done! You now have the latest version of ELRS on your hardware. Go Fly! \ud83d\ude81</p>","title":"Wifi Updating"}]}